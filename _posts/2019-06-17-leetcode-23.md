---
layout: post
title: leetcode23动态规划|未通过|最长有效括号
categories: [leetcode]
---

1. 设置dp[][]当dp[i][j] == 1时就是表示i与j之间是联通的，从而找到最大的子列和

2. 一种解法，设立一个数组只要是一对的括号就将数组相应的位置置为1，最后检查连续的1的最长的长度，方法与上面的使用dp[][]的用法相同

3. 也要使用递归的方法解决一下
假设输入的字符串序列为：")))()()()()(((((  ((())) ((((((())))))) )))))"

！！！不会希望有一天能够解决！！！


/*
	
	使用递归求解：还需要进入的递归函数之间的交流来确定最大值
				  还需要使用for循环来寻找最长有效括号的起点

	终止条件：并没有终止条件将所有循环结束就截止
				！！新终止条件：直到找不到一对括号为止

	这道题为啥使用递归的方法不容易做，而最大子列和问题使用递归的方法就比较容易（进行分治，而且这个分治写起来比较简单）

	使用递归的难点在于：递归要求能够层层调用自己，即子问题之间是没有关系的(如求利用最少的钞票数量来凑成合适的面值)或者是关系比较简单比如最大子列和问题中的使用递归的二分法来求解最大子列和
			（这种递归之间的关系是比较简单的）；但是这个递归问题


*/
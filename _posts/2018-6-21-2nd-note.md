---
layout: post
title: 第二章笔记
categories: [C/C++]
tags: CBIR
---

## P113

如何理解复杂的引用变量的定义：

ia[2][3] = arr[0][0][0]

int (&row)[4] = ia[1]  //**把row绑定到ia的第二个4元素数组上**

//如何理解这样的定义的方法

在这个例子中，把row定义为一个含有4个整数的引用，然后将其绑定到ia的第二行中

同时我们还可以这样来理解：

int (&row)[4] = ia[1] = x[4] ==> &row = x ==> 所以row就是x的引用也就是一个含有4个元素的数组的引用。

## P114

```
//在C++11中我们可以使用范围for语句来处理多维数组

size_t cnt = 0;
for(auto &row:ia)
	for(auto &col : row){
		col = cnt;
		++cnt;
}
//另外我们需要注意
size_t cnt = 0;
for(auto &row:ia)
	for(auto col : row){
		col = cnt;
		++cnt;
}
//这样写是正确的
size_t cnt = 0;
for(auto row:ia)
	for(auto col : row){
		col = cnt;
		++cnt;
}
//这样写是错误的。因为row不是引用类型，所以编译器初始化row时会自动将这些数组形式的元素（和其他类型的数组一样）转换为指向该数组内首元素的指针？？这样内层循环显然就是不合法的了。
```

## P115

指向多维数组的指针的定义以及解释

### 定义指向多维数组的指针时，千万不要忘了这个多维数组实际上是数组的数组
```
int ia[3][4];
int (*p)[4] = ia;
p = &ia[2];
```

如何分析p的相关策略：我们可以先由内层到外层一层一层的进行分析；先由括号内一层进行分析可得p是一个指针，这个指针指向的是一个维度为4的数组。**注意：不同于int *p[4] = x;**还有就是类似:

```
int *(&arry)[10] = ptrs;//
```

按照由内向外的顺序阅读上述语句，首先知道arry是一个引用，然后我们**由运算符的优先级顺序可知**我们应该观察右边，观察右边我们知道，arry引用的对象一个大小为10的数组，最后观察左边我们知道，数组的元素类型是指向int的指针。这样，arry就是一个含有10个int型指针的数组的引用。

## 116  typedef 和c++11中的using

using int_array = int[4];
typedef int int_array[4];

二者等价，不过使用using的时候表达式更为简单容易理解
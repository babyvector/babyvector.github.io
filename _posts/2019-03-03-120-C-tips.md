---
layout: post
title: 改善C程序代码的125个建议 
categories: [C/C++]
---

1. 建议1：认识ANSI C

	略

2. 防止整数类型产生回绕与溢出
	* 2-1.char类型变量的值应该限制在signed char与unsigned char的交集范围内
	* 2-2.使用显式声明为signed char或unsigned char的类型来执行算术运算
	* 2-3.使用rsize_t或size_t类型来表示一个对象所占用空间的整数值单位
	
		size_t是一种无符号整数类型。编译器根据操作系统位数的不同而用typedef来定义不同的size_t类型，即在不同的操作系统上所定义的的size_t可能不一样。size_t类型的限制是由SIZE_MAX宏指定的。


		int 类型的限制是由INT_MAX宏指定的。而size_t类型代表的是一个无符号整数类型，它可能包含一个大于INT_MAX的值。所以二者配合使用的时候要注意不要数组越界。
	* 2-4.禁止把size_t类型和它所代表的真实类型混用
```
		unsigned int x;
		size_t y;
		x = y;
```
        由于size_t类型的数据在不同的操作系统中的定义的长度不相同，因此在执行 **x=y** 的时候可能会将y的高位截断，使数据出错。
	* 2-5.小心使用无符号类型带来的陷阱
	
        **当有符号整数类型和无符号整数类型进行运算时，有符号整数类型会先自动转化为无符号整数类型。**
```	
		int i = -1;
		if( i<=sizeof(array) ){;}
		当进行<=符号运算的时候，i在32位计算中表示为0xffffffff当作为无符号整数的时候就是：4294967295
```	
        **建议：在使用数字的时候尽量都使用有符号数字，如果实在无法避免就将无符号数强制类型转换为有符号类型再进行运算。例如：i<=(int)sizeof(array)**

	* 2-6.防止无符号数整数回绕 
        **如果数值超过无符号数整型数据的限定长度就会发生回绕，即如果无符号整形变量的值超过了无符号整型的上限就会返回0然后从0开始增长。**
    * 2-7.防止有符号整数溢出

		在32位操作系统中，类型int的取值范围为-2147483647~2147483647
```
		#define INT_MIN	(-2147483647-1)
		#define	INT_MAX (2147483647)
```

		在编写计算机程序的时候可以通过对操作数进行预测的方法来避免发生有符号整数运算的溢出。

3. 尽量少使用浮点类型
	
    * 3-1了解IEEE 754浮点数
	
    
        C语言标准规定的浮点数据类型有float、double、long double三种。
```
		ANSI标准规定的浮点数据类型
		类型				位数				最小取值范围
		float			32				6位精度，1E-37~1E+37
		double			64				10位精度，1E-37~1E+37
		long double		80   			10位精度，1E-37~1E+37
```

        long double类型可能有不同的实现有的是8字节，有的是10字节，有的是12字节。一般来说long double类型的精度都要高于double类型**至少他们也应该相等**
```
		float f1 = 34.6
		float f2 = 34.5
		float f3 = 34.0
		打印之后显示：为f1-f3=0.599998，产生这个误差的原因是34.6无法精确地表示为相应的浮点数。
```
        如果想要将十进制数转换为二进制数，则需要把整数部分和小数部分分别转换。其中，整数部分除以2，取余数；小数部分乘以2，取整数。

        IEEE浮点数标准是从逻辑上用三元组{S,E,M}来表示一个数V的，即$$V=(-1)^5\times M\times2^E$$
```
	|--------------------------------------------------------|
	| S(符号位)|     E(指数位)      |      M(有效数字位)       |                                             
	|--------------------------------------------------------|
```
IEEE浮点数的表示形式
      
        * 符号位s(Sign)决定是正数(s=0)还是负数(s=1)，而对于数值0的符号位解释则作为特殊情况处理。

        * 有效数字位M(Signigicand)是二进制小数

        * 指数位E(Exponent)是2的幂（可能是负数），它的作用是对浮点数加权
   
        **实例**：十进制-9.625(也就是二进制1001.101 也可以表达为$$1.001101\times2^3$$)
   
        因为-9.625是负数，所以符号段为1.而这里的指数为3，所以指数段为$$3+127=130$$，即为二进制的10000010。有效数字省略掉小数点左侧的1之后为001101，然后在右侧用零补齐。因此所得的最终结果为：1|10000010|00110100000000000000000

        **对于浮点格式来讲，值+0.0和值-0.0在某些方面是不同的**

    * 3-2.避免使用浮点数进行精确计算
        由于计算机的字长有限，浮点数能够精确表示的数是有限的。因此在进行数值计算时，有可能要对计算得到的中间结果数据使用相关的舍入规则来取近似值。例如当我们把9个5.1相加之后再取平均值结果得到的数据是5.09999。产生这种状况的原因就是计算机中无法准确的表示出5.1。**因此**，应该尽量避免使用浮点数进行精确运算。
    * 3-3.使用分数来精确表达浮点数

        一般实际工程中可以使用这种方法。
    * 3-4.避免直接再浮点数中使用"=="操作符做相等判断
        在判断整数是否相等的时候可以使用这种方法，但是**当我们使用这种方法判断两个浮点数是否相等时候，就是必须两个浮点数中的每一位都必须相等.**

        因此，当判断两个浮点数是否相等的时候可以使用如下方式进行判断：
		```
		if(fabs(a-b) < epsilon)
		```
* 3-5.避免使用浮点数作为循环计数器
* 3-6.尽量将浮点运算中的整数转换为浮点数（之后再进行运算，保证运算结果正确）
4. 数据类型转换必须做范围检查
   在C语言中数据类型转换一般分为**隐式转换**和**显式转换**也成为**自动转换**和**强制转换**
   * 4-1.整数转换为新类型的时候必须做范围检查
   * 4-2.浮点数转换为新类型的时候必须做范围检查

5. 使用有严格定义的数据类型
6. 使用typedef来定义类型的新别名
    * 6-1.掌握typedef的4种应用形式
    	
        * 为基本数据类型定义新的类型名
    	
        * 为自定义数据类型（结构体、共用体、枚举类型）定义简洁的类型名称
    	
        * 为数组定义简介的类型名称
     	
        * 为指针定义简介的名称
        
    * 6-2.小心使用typedef带来的陷阱
		typedef是用来定义一种类型的新别名的，它不同于宏，不是简单的字符串替换。
    * 6-3.typedef不同于#define
		\#define只是简单的字符串替换
			```
				typedef char * PCHAR1;
				#define PCHAR2 char *
				PCHAR1 c1,c2;
				PCHAR2 c3,c4;
				
				PCHAR2 在这个过程中只是被替代为char *
			```
7. 变量声明应该力求简洁
	* 7-1.尽量不要在一个声明中声明超过一个变量

		除此之外，尽量尽可能在声明变量的同时初始化该变量

    * 7-2.避免在嵌套的代码之间使用相同的变量

		因为虽然C语言允许在同一源文件中全局变量和局部变量同名，但在局部变量的作用域内，全局变量将不再起任何作用

8. 正确地选择变量的存储类型
    * 8-1.定义局部变量时应该省略auto关键词
	
	* 8-2. 慎用extern声明外部变量
	
	
		    变量分为：静态存储和动态存储
			
			局部变量是在一个函数或复合语句内定义的变量
		
		  
		   
		    如果全局变量不在文件的开头定义，有效的作用范围将只限于其定义处到文件结束。如果在定义点之前的函数想引用该全局变量，则应该在引用之前用关键字extern对该变量做"外部变量声明",表示该变量是一个已经定义的外部变量。有了这个声明就可以从“声明”处起使用该变量。
		
			```
			#include<stdio.h>
			int max(int x,int y);
			int main(){
				int result;
				/*外部变量声明*/
				extern int g_x;
				extern int g_y;
				result = max(g_x,g_y);
				printf("the max value is %d\n",result);
				return 0;
			}
			/*定义两个全局变量*/
			int g_x = 10;
			int g_y = 20;
			int max(int x,int y){
				return (x>y?x:y);
			}
			
			```
		
		    外部变量接口都是在模块程序的头文件中声明的。
  
	* 8-3.不要混淆static变量的作用
		
		static关键字不仅可以用来修饰变量，还可以用来修饰函数

   		1. 隐藏与隔离的作用
			static限制作用域在一个文件或大括号单元中，也就起到了对其他源文件进行隐藏与隔离错误的作用。
		2. 保持变量内容的持久性
			其实静态局部变量与全局变量的主要区别就在于可见性，静态局部变量只在其被声明的代码块中式可见的
		3. 默认初始化为0
			在静态数据区，内存中所有的字节默认值都是0x00
	* 8-4. 不要使用register变量
9. 不要在可重入函数中使用静态（或全局）变量
	所谓的可重入函数是指函数可以由多于一个任务并发使用，当需要设计一个可重入式的函数的时候一定要避免使用static变量与全局变量。因为这些函数只要调用一次之后其相应的static和全局变量就会发生改变，当再次调用这个函数的时候得不到预期的结果。
10. 尽量少使用全局变量
11. 尽量使用const声明值不会改变的变量
	1. const变量是只读变量，不是常量
	2. 确保变量的值不会被修改（这里有一点不是很理解）
12. 尽量减少使用除法运算与求模运算
	* 12-1.用倒数相乘来实现除法运算
		在IA-32处理器中，乘法指令的运算速度比除法指令要快4-6倍。
	* 12-2.使用牛顿迭代法求除数的倒数
		（自己感觉首先要将程序完整的写下来再根据程序的数字特征，做相应的优化。）
	* 12-3.用减法运算来实现整数除法运算
	* 12-4.用移位运算实现乘除法运算
	* 12-5.尽量将浮点除法转换为相应的整数除法运算
13. 保证除法和求模运算不会导致除0错误
14. 适当的使用位操作来提高计算效率（P89代码不是很理解，这一部分都不是很理解）
	* 14-1. 尽量避免对未知的有符号数执行位操作（？）
	* 14-2. 在右移中合理地选择0或符号位来填充空出的位
		（同时，如果一个程序采用了有符号数的右移操作，那么它就是不可移植的）
	* 14-3. 移位的数量必须大于等于0且小于操作数的位数
	* 14-4. 尽量避免在同一个数据上致性位操作与算术运算

	最终总结：适当的使用是可以提高一定的效率，但是对于现代的编译器而言，编译器已经能顾帮助我们做很多又很好的优化了。
15. 避免操作符混淆
	* 15-1.避免“=”与“==”混淆
	* 15-2.避免“|”与“||”混淆
	* 15-3.避免“&”与“&&”混淆
```
x|y = (1101|1100) = 1101
```
16. 表达式的设计应该兼顾效率与可读性
	* 16-1. 尽量使用复合赋值运算符（但是是以程序的可读性为前提的）
	* 16-2. 尽量避免编写多用途的、太复杂的复合表达式
		如果代码行中的运算符比较多，应当用括号明确表达式的计算顺序，从而避免采用默认的运算符优先级。
	*  **注意这里的优先级列表**
		注意将"a|b<c&d"等价于"a|(b<c)&d,这就造成了判断条件出错"
17. if语句应该尽量保持简洁，减少嵌套层数
	* 17-1.先处理正常情况再处理异常情况
		我们应该把正常情况的处理放在if后面
	* 17-2.避免悬挂的else
		一般要再if/else的后面写上{}
	* 17-3.避免再if/else语句后面添加分号";"
	* 17-4.对深层嵌套的if语句进行重构
18. 谨慎0值比较
	* 18-1.避免布尔型与0或1比较
		visual C++中将true定义为1，但是在visual Basic中则是将true定义为-1。
```
一般情况下的代码书写：
if(flag)/*表示flag为真*/
if(!flag)/*表示flag为假*/
```
	* 18-2.整型变量应该直接与0进行比较
	* 18-3.避免浮点变量用“==”或“！=”与0进行比较
	* 18-4.指针变量应该用“==”或“！=”与NULL进行比较
19. 避免使用嵌套的"?:"
20. 正确使用for循环
	* 20-1.尽量使循环控制变量的取值采用半开半闭区间写法
		半开半闭区间写法更能直观地表达意思，具有更高的可读性。
	* 20-2.尽量使循环体内工作量达到最小化
		在一个for循环内不能代码众多（一般而言循环体内的代码不要超过20行，甚至不能超过一屏）
	* 20-3.避免在循环体内修改循环变量（容易出现死循环或者出错）
	* 20-4.尽量使逻辑判断语句置于循环语句外层
```
for(int i = 0;i<n;i++){
	if(condition){
		DoSomething();
	}else{
		DoOtherthing();
	}
}
```
```
if(condition){
	for(int i = 0;i<n;i++){
		DoSomething();
	}
}else{
	for(){
		DoOtherthing();
	}
}
```
	* 20-6.尽量将循环嵌套控制在3层以内
		如果超过3层，建议重新设计循环或将循环内的代码改成一个子函数。
21. 适当地使用并行代码来优化for循环
```
double num[100];
double sum = 0;
double sum1 = 0;
double sum2 = 0;
double sum3 = 0;
double sum4 = 0;
int i = 0;
for(int i = 0;i<100;i+=4){
	sum1+=num[i];
	sum2+=num[i+1];
	sum3+=num[i+2];
	sum4+=num[i+3];
}
sum = sum4+sum3+sum2+sum1;
```
22. 谨慎使用do/while与while循环（最好不用do/while）
	* 22-1. 无限循环优先选用for(;;),而不是while(1)
	* 22-2. 优先使用for循环代替do/while与while循环
23. 正确地使用switch语句
	* 23-1.不要忘记在case语句的结尾添加break语句
	* 23-2.不要忘记在switch语句的结尾添加default语句
	* 23-3.不要为了使用case语句而可以构造一个变量
	* 23-4.尽量将长的switch语句转换为嵌套switch语句
	注意：switch语句与if语句不同的是，switch语句只能够测试是否相等。
```
//以下是比较标准的switch语句的写法
#include<stdio.h>

void print_week(unsigned int day);
void print_week(unsigned int day){
	switch(day){
		case 1:
			printf();
			break;
		case 2:
			printf();
			break;
		case 3:
			printf();
			break;
		default:
			printf("error\n");
			break;
	}
}
```
24. 选择合理的case语句排序方法
	* 24-1. 尽量按照字母或数字顺序来排列各条case语句
	* 24-2. 尽量将情况正常的case语句排列在最前面
	* 24-3. 尽量根据发生频率来排列各条case语句
25. 尽量避免使用goto语句（不要使用）
	goto语句最有优势的一个用法是：如果陷入很深层次的循环中想要跳出最外层的循环，用goto直接跳出比用break一层循环一层循环跳出好的多。
26. 区别continue与break语句
	break语句不能用于循环语句和switch之外的任何其他语句中。
27. 理解函数声明
	(*((void(*)())0))()
	(void(*)())代表强制类型转换
	*0x00000代表取地址执行
	比如一个函数f()，其中f代表的就是这段代码的地址，而f()就是代表执行这段代码。
28. 理解函数原型
	如果在被调用之前没有给出函数原型，则编译器会将第一次遇到的该函数定义作为函数的声明，并将函数返回值类型默认为int型。
29. 尽量使函数的功能单一
	注意：函数应该很精确的执行一件事，明确函数功能（一个函数仅能完成一件事情），精确（而不是近似）地实现函数设计。
30. 避免把没有关联的语句放在一个函数中
31. 函数的抽象级别应该在同一层次
```
//这种结构不够好，因为本地初始化与远程初始化应该处于同一抽象层
void Init(void){
	/*本地初始化*/
	...
	InitRemote();
}
void InitRemote(void){
	/*远程初始化*/
	...
}
```
32. 尽可能为简单功能编写函数
	预处理器用复制宏代码的方式代替函数调用，省去了参数压栈、生成汇编语言的CALL调用、返回参数、执行return等过程，从而提高了运行速度。
33. 避免多段代码重复做同一件事情
34. 尽量避免编写不可重入函数
	* 34-1. 避免在函数中使用static局部变量
	* 34-1. 避免函数返回指向静态数据的指针
	* 34-3. 避免调用任何不可重入的函数
		在程序中，如果一个函数调用了另外一个不可重入函数，那么这个函数一定是不可重入的。
	* 34-4. 对于全局变量，应通过互斥信号量(即P,V操作)或者中断机制等方法来保证函数的线程安全
		```
			int g = 10;
			int Test(){
				return g++;
			}
		```
		在上面的代码中，函数Test使用了全局变量g，如果两个或多个线程同时执行它并访问全局变量g，则返回的结果取决于执行的时间。因此，函数Test不可重入。
	* 34-5. 理解可重入函数与线程安全函数之间的关系
		对于可重入函数，可以由一个或者多个函数并发使用，而不用担心数据数据错误，同时，可重入函数也可以在任意时刻被中断，稍后继续运作，也不用担心丢失数据。因此可重入函数要么使用本地变量，要么在使用全局变量时保护自己的数据。**相反**，可重入函数则不能由超过一个任务共享，除非能确保函数的互斥（使用互斥信号量或者在代码的关键部分禁用中断）
35. 尽量避免设计多参数函数
	* 35-1. 没有参数的函数必须使用void填充
	* 35-2. 尽量避免在非调度函数中使用控制参数
	* 35-3. 避免将函数的参数作为工作变量
	* 35-4. 使用const防止指针类型的输入参数在函数体内被意外修改
36. 没有返回值的函数应声明为void类型
37. 确保函数体的“入口”与“出口”安全性
	* 37-1. 尽量在函数体入口处对参数做有效性检查
		```
			char *Strncopy(char *dest,const char *src,size_t size){
				assert( (dest != NULL) && (src != NULL) );
				...
			}
		```
	* 37-2. 尽量在函数体出口处对return语句做安全性检查
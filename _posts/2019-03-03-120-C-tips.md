---
layout: post
title: 改善C程序代码的125个建议 
categories: [C/C++]
---

# <center>第1章：数据，程序设计之根本</center>
### 建议1：认识ANSI C

略

### 建议2：防止整数类型产生回绕与溢出

* 2-1.char类型变量的值应该限制在signed char与unsigned char的交集范围内
* 2-2.使用显式声明为signed char或unsigned char的类型来执行算术运算
* 2-3.使用rsize_t或size_t类型来表示一个对象所占用空间的整数值单位
	
	size_t是一种无符号整数类型。编译器根据操作系统位数的不同而用typedef来定义不同的size_t类型，即在不同的操作系统上所定义的的size_t可能不一样。size_t类型的限制是由SIZE_MAX宏指定的。


	int 类型的限制是由INT_MAX宏指定的。而size_t类型代表的是一个无符号整数类型，它可能包含一个大于INT_MAX的值。所以二者配合使用的时候要注意不要数组越界。
* 2-4.禁止把size_t类型和它所代表的真实类型混用
	
		unsigned int x;
		size_t y;
		x = y;

    
    由于size_t类型的数据在不同的操作系统中的定义的长度不相同，因此在执行 **x=y** 的时候可能会将y的高位截断，使数据出错。
	
* 2-5.小心使用无符号类型带来的陷阱
	
	**当有符号整数类型和无符号整数类型进行运算时，有符号整数类型会先自动转化为无符号整数类型。**

		```	
		int i = -1;
		if( i<=sizeof(array) ){;}
		当进行<=符号运算的时候，i在32位计算中表示为0xffffffff当作为无符号整数的时候就是：4294967295
		```	

     **建议：在使用数字的时候尽量都使用有符号数字，如果实在无法避免就将无符号数强制类型转换为有符号类型再进行运算。**

	**例如：i<=(int)sizeof(array)**

* 2-6.防止无符号数整数回绕 

        **如果数值超过无符号数整型数据的限定长度就会发生回绕，即如果无符号整形变量的值超过了无符号整型的上限就会返回0然后从0开始增长。**

* 2-7.防止有符号整数溢出

		在32位操作系统中，类型int的取值范围为-2147483647~2147483647
		```
				#define INT_MIN	(-2147483647-1)
				#define	INT_MAX (2147483647)
		```

		在编写计算机程序的时候可以通过对操作数进行预测的方法来避免发生有符号整数运算的溢出。

### 建议3：尽量少使用浮点类型
	
* 3-1了解IEEE 754浮点数
	
	C语言标准规定的浮点数据类型有float、double、long double三种。

		```
		ANSI标准规定的浮点数据类型
		类型				位数				最小取值范围
		float			32				6位精度，1E-37~1E+37
		double			64				10位精度，1E-37~1E+37
		long double		80   			10位精度，1E-37~1E+37
		```

	long double类型可能有不同的实现有的是8字节，有的是10字节，有的是12字节。一般来说long double类型的精度都要高于double类型**至少他们也应该相等**


		```
		float f1 = 34.6
		float f2 = 34.5
		float f3 = 34.0
		打印之后显示：为f1-f3=0.599998，产生这个误差的原因是34.6无法精确地表示为相应的浮点数。
		```

	如果想要将十进制数转换为二进制数，则需要把整数部分和小数部分分别转换。其中，整数部分除以2，取余数；小数部分乘以2，取整数。
	
	IEEE浮点数标准是从逻辑上用三元组{S,E,M}来表示一个数V的，即$$V=(-1)^5\times M\times2^E$$

		|--------------------------------------------------------|
		| S(符号位)|     E(指数位)      |      M(有效数字位)       |                                             
		|--------------------------------------------------------|

	**IEEE浮点数的表示形式：**
      
    * 符号位s(Sign)决定是正数(s=0)还是负数(s=1)，而对于数值0的符号位解释则作为特殊情况处理。

    * 有效数字位M(Signigicand)是二进制小数

    * 指数位E(Exponent)是2的幂（可能是负数），它的作用是对浮点数加权

        **实例**：十进制-9.625(也就是二进制1001.101 也可以表达为$$1.001101\times2^3$$)
   
	因为-9.625是负数，所以符号段为1.而这里的指数为3，所以指数段为$$3+127=130$$，即为二进制的10000010。有效数字省略掉小数点左侧的1之后为001101，然后在右侧用零补齐。因此所得的最终结果为：1|10000010|00110100000000000000000

   	**对于浮点格式来讲，值+0.0和值-0.0在某些方面是不同的**

* 3-2.避免使用浮点数进行精确计算

	由于计算机的字长有限，浮点数能够精确表示的数是有限的。因此在进行数值计算时，有可能要对计算得到的中间结果数据使用相关的舍入规则来取近似值。例如当我们把9个5.1相加之后再取平均值结果得到的数据是5.09999。产生这种状况的原因就是计算机中无法准确的表示出5.1。**因此**，应该尽量避免使用浮点数进行精确运算。
   
* 3-3.使用分数来精确表达浮点数

    一般实际工程中可以使用这种方法。
    
* 3-4.避免直接再浮点数中使用"=="操作符做相等判断
    
    在判断整数是否相等的时候可以使用这种方法，但是**当我们使用这种方法判断两个浮点数是否相等时候，就是必须两个浮点数中的每一位都必须相等.**

    因此，当判断两个浮点数是否相等的时候可以使用如下方式进行判断：
	
		```
		if(fabs(a-b) < epsilon)
		```
* 3-5.避免使用浮点数作为循环计数器
* 3-6.尽量将浮点运算中的整数转换为浮点数（之后再进行运算，保证运算结果正确）
### 建议4：数据类型转换必须做范围检查
   在C语言中数据类型转换一般分为**隐式转换**和**显式转换**也成为**自动转换**和**强制转换**
   * 4-1.整数转换为新类型的时候必须做范围检查
   * 4-2.浮点数转换为新类型的时候必须做范围检查

### 建议5：使用有严格定义的数据类型

### 建议6：使用typedef来定义类型的新别名

* 6-1.掌握typedef的4种应用形式
	
    * 为基本数据类型定义新的类型名
	
    * 为自定义数据类型（结构体、共用体、枚举类型）定义简洁的类型名称
	
    * 为数组定义简介的类型名称
 	
    * 为指针定义简介的名称
    
* 6-2.小心使用typedef带来的陷阱
	typedef是用来定义一种类型的新别名的，它不同于宏，不是简单的字符串替换。
* 6-3.typedef不同于#define
	\#define只是简单的字符串替换

		```
			typedef char * PCHAR1;
			#define PCHAR2 char *
			PCHAR1 c1,c2;
			PCHAR2 c3,c4;
			
			PCHAR2 在这个过程中只是被替代为char *
		```

### 建议7：变量声明应该力求简洁

* 7-1.尽量不要在一个声明中声明超过一个变量

	除此之外，尽量尽可能在声明变量的同时初始化该变量

* 7-2.避免在嵌套的代码之间使用相同的变量

	因为虽然C语言允许在同一源文件中全局变量和局部变量同名，但在局部变量的作用域内，全局变量将不再起任何作用

### 建议8：正确地选择变量的存储类型

* 8-1.定义局部变量时应该省略auto关键词

* 8-2. 慎用extern声明外部变量

	变量分为：静态存储和动态存储
		
	局部变量是在一个函数或复合语句内定义的变量
	
	如果全局变量不在文件的开头定义，有效的作用范围将只限于其定义处到文件结束。如果在定义点之前的函数想引用该全局变量，则应该在引用之前用关键字extern对该变量做"外部变量声明",表示该变量是一个已经定义的外部变量。有了这个声明就可以从“声明”处起使用该变量。
	
		```
		#include<stdio.h>
		int max(int x,int y);
		int main(){
			int result;
			/*外部变量声明*/
			extern int g_x;
			extern int g_y;
			result = max(g_x,g_y);
			printf("the max value is %d\n",result);
			return 0;
		}
		/*定义两个全局变量*/
		int g_x = 10;
		int g_y = 20;
		int max(int x,int y){
			return (x>y?x:y);
		}
		
		```
	
	    外部变量接口都是在模块程序的头文件中声明的。

* 8-3.不要混淆static变量的作用
	
	static关键字不仅可以用来修饰变量，还可以用来修饰函数

	1. 隐藏与隔离的作用
	
		static限制作用域在一个文件或大括号单元中，也就起到了对其他源文件进行隐藏与隔离错误的作用。
	2. 保持变量内容的持久性
	
		其实静态局部变量与全局变量的主要区别就在于可见性，静态局部变量只在其被声明的代码块中式可见的
	3. 默认初始化为0
	
		在静态数据区，内存中所有的字节默认值都是0x00
	4. 肖老师关于静态变量|初始化与赋值的不同
	
			{%highlight ruby%}
			#include <stdio.h>
			#include <stdlib.h>
			void foo();
			int main()
			{
			    printf("Hello world!\n");
			
			    for(int i = 0;i<10;i++){
			        foo();
			        foo2();
			    }
			    getchar();
			    getchar();
			    return 0;
			}
			void foo(){
			    static int i = 0;
			    //注意初始化语句并不是执行语句
			    //static在程序开始的时候都已经创建了，当执行到这个语句
			    //时候并不会再次被创建
			    //与全局变量不同的是这个静态变量只有在这个函数中可以使用
			    i++;
			    printf("the value in foo1 i is:%d\n",i);
			}
			{%endhighlight%}
	
* 8-4. 不要使用register变量

### 建议9：不要在可重入函数中使用静态（或全局）变量
	
	所谓的可重入函数是指函数可以由多于一个任务并发使用，当需要设计一个可重入式的函数的时候一定要避免使用

	static变量与全局变量。因为这些函数只要调用一次之后其相应的static和全局变量就会发生改变，当再次调用

	这个函数的时候得不到预期的结果。

### 建议10：尽量少使用全局变量

### 建议11：尽量使用const声明值不会改变的变量

1. const变量是只读变量，不是常量
2. 确保变量的值不会被修改（这里有一点不是很理解）

# <center>第2章：保持严谨的程序设计，一切从表达式开始做起</center>

### 建议12：尽量减少使用除法运算与求模运算

* 12-1.用倒数相乘来实现除法运算

	在IA-32处理器中，乘法指令的运算速度比除法指令要快4-6倍。
	
* 12-2.使用牛顿迭代法求除数的倒数
	
	（自己感觉首先要将程序完整的写下来再根据程序的数字特征，做相应的优化。）
	
* 12-3.用减法运算来实现整数除法运算
	
* 12-4.用移位运算实现乘除法运算
	
* 12-5.尽量将浮点除法转换为相应的整数除法运算

### 建议13： 保证除法和求模运算不会导致除0错误

### 建议14： 适当的使用位操作来提高计算效率（P89代码不是很理解，这一部分都不是很理解）

* 14-1. 尽量避免对未知的有符号数执行位操作（？）

* 14-2. 在右移中合理地选择0或符号位来填充空出的位

	（同时，如果一个程序采用了有符号数的右移操作，那么它就是不可移植的）
	
* 14-3. 移位的数量必须大于等于0且小于操作数的位数
	
* 14-4. 尽量避免在同一个数据上致性位操作与算术运算

	最终总结：适当的使用是可以提高一定的效率，但是对于现代的编译器而言，编译器已经能顾帮助我们做很多又很好的优化了。

### 建议15： 避免操作符混淆

* 15-1.避免“=”与“==”混淆

* 15-2.避免“|”与“||”混淆

* 15-3.避免“&”与“&&”混淆

		```
		x|y = (1101|1100) = 1101
		```

### 建议16： 表达式的设计应该兼顾效率与可读性

* 16-1. 尽量使用复合赋值运算符（但是是以程序的可读性为前提的）

* 16-2. 尽量避免编写多用途的、太复杂的复合表达式

	如果代码行中的运算符比较多，应当用括号明确表达式的计算顺序，从而避免采用默认的运算符优先级。

*  **注意这里的优先级列表**

	注意将"a|b<c&d"等价于"a|(b<c)&d,这就造成了判断条件出错"

# <center>第3章：程序控制语句应该保持简洁高效</center>

### 建议17： if语句应该尽量保持简洁，减少嵌套层数
	
* 17-1.先处理正常情况再处理异常情况
	
	我们应该把正常情况的处理放在if后面
	
* 17-2.避免悬挂的else
	一般要再if/else的后面写上{}
	
* 17-3.避免再if/else语句后面添加分号";"
	
* 17-4.对深层嵌套的if语句进行重构

### 建议18： 谨慎0值比较

* 18-1.避免布尔型与0或1比较
	
	visual C++中将true定义为1，但是在visual Basic中则是将true定义为-1。

		```
		一般情况下的代码书写：
		if(flag)/*表示flag为真*/
		if(!flag)/*表示flag为假*/
		```

* 18-2.整型变量应该直接与0进行比较
	
* 18-3.避免浮点变量用“==”或“！=”与0进行比较
	
* 18-4.指针变量应该用“==”或“！=”与NULL进行比较

### 建议19： 避免使用嵌套的"?:"

### 建议20： 正确使用for循环

* 20-1.尽量使循环控制变量的取值采用半开半闭区间写法

	半开半闭区间写法更能直观地表达意思，具有更高的可读性。
	
* 20-2.尽量使循环体内工作量达到最小化
	
	在一个for循环内不能代码众多（一般而言循环体内的代码不要超过20行，甚至不能超过一屏）
	
* 20-3.避免在循环体内修改循环变量（容易出现死循环或者出错）
	
* 20-4.尽量使逻辑判断语句置于循环语句外层

		```
		for(int i = 0;i<n;i++){
			if(condition){
				DoSomething();
			}else{
				DoOtherthing();
			}
		}
		```
		
		```
		if(condition){
			for(int i = 0;i<n;i++){
				DoSomething();
			}
		}else{
			for(){
				DoOtherthing();
			}
		}
		```
	
* 20-6.尽量将循环嵌套控制在3层以内
	
	如果超过3层，建议重新设计循环或将循环内的代码改成一个子函数。

### 建议21： 适当地使用并行代码来优化for循环

		```
		double num[100];
		double sum = 0;
		double sum1 = 0;
		double sum2 = 0;
		double sum3 = 0;
		double sum4 = 0;
		int i = 0;
		for(int i = 0;i<100;i+=4){
			sum1+=num[i];
			sum2+=num[i+1];
			sum3+=num[i+2];
			sum4+=num[i+3];
		}
		sum = sum4+sum3+sum2+sum1;
		```

### 建议22： 谨慎使用do/while与while循环（最好不用do/while）

* 22-1. 无限循环优先选用for(;;),而不是while(1)

* 22-2. 优先使用for循环代替do/while与while循环

### 建议23： 正确地使用switch语句

* 23-1.不要忘记在case语句的结尾添加break语句
	
* 23-2.不要忘记在switch语句的结尾添加default语句

* 23-3.不要为了使用case语句而可以构造一个变量

* 23-4.尽量将长的switch语句转换为嵌套switch语句
	
	注意：switch语句与if语句不同的是，switch语句只能够测试是否相等。

		```
		//以下是比较标准的switch语句的写法
		#include<stdio.h>
		
		void print_week(unsigned int day);
		void print_week(unsigned int day){
			switch(day){
				case 1:
					printf();
					break;
				case 2:
					printf();
					break;
				case 3:
					printf();
					break;
				default:
					printf("error\n");
					break;
			}
		}
		```
### 建议24： 选择合理的case语句排序方法

* 24-1. 尽量按照字母或数字顺序来排列各条case语句

* 24-2. 尽量将情况正常的case语句排列在最前面

* 24-3. 尽量根据发生频率来排列各条case语句

### 建议25： 尽量避免使用goto语句（不要使用）

goto语句最有优势的一个用法是：如果陷入很深层次的循环中想要跳出最外层的循环，用goto直接跳出比用break一层循环一层循环跳出好的多。

### 建议26： 区别continue与break语句

break语句不能用于循环语句和switch之外的任何其他语句中。

# <center>第4章：函数同样需要保持高效简洁</center>

### 建议27： 理解函数声明

(*((void(*)())0))()

(void(*)())代表强制类型转换

*0x00000代表取地址执行

比如一个函数f()，其中f代表的就是这段代码的地址，而f()就是代表执行这段代码。

### 建议28： 理解函数原型

如果在被调用之前没有给出函数原型，则编译器会将第一次遇到的该函数定义作为函数的声明，并将函数返回值类型默认为int型。

### 建议29： 尽量使函数的功能单一
	
注意：函数应该很精确的执行一件事，明确函数功能（一个函数仅能完成一件事情），精确（而不是近似）地实现函数设计。

### 建议30： 避免把没有关联的语句放在一个函数中

### 建议31： 函数的抽象级别应该在同一层次

		```
		//这种结构不够好，因为本地初始化与远程初始化应该处于同一抽象层
		void Init(void){
			/*本地初始化*/
			...
			InitRemote();
		}
		void InitRemote(void){
			/*远程初始化*/
			...
		}
		```

### 建议32： 尽可能为简单功能编写函数
	
预处理器用复制宏代码的方式代替函数调用，省去了参数压栈、生成汇编语言的CALL调用、返回参数、执行return等过程，从而提高了运行速度。

### 建议33： 避免多段代码重复做同一件事情

### 建议34： 尽量避免编写不可重入函数

* 34-1. 避免在函数中使用static局部变量
	
* 34-1. 避免函数返回指向静态数据的指针
	
* 34-3. 避免调用任何不可重入的函数

	在程序中，如果一个函数调用了另外一个不可重入函数，那么这个函数一定是不可重入的。
	
* 34-4. 对于全局变量，应通过互斥信号量(即P,V操作)或者中断机制等方法来保证函数的线程安全
		```
			int g = 10;
			int Test(){
				return g++;
			}
		```
	
	在上面的代码中，函数Test使用了全局变量g，如果两个或多个线程同时执行它并访问全局变量g，则返回的结果取决于执行的时间。因此，函数Test不可重入。
	
* 34-5. 理解可重入函数与线程安全函数之间的关系

	对于可重入函数，可以由一个或者多个函数并发使用，而不用担心数据数据错误，同时，可重入函数也可以在任意时刻被中断，稍后继续运作，也不用担心丢失数据。因此可重入函数要么使用本地变量，要么在使用全局变量时保护自己的数据。**相反**，可重入函数则不能由超过一个任务共享，除非能确保函数的互斥（使用互斥信号量或者在代码的关键部分禁用中断）

### 建议35： 尽量避免设计多参数函数

* 35-1. 没有参数的函数必须使用void填充

* 35-2. 尽量避免在非调度函数中使用控制参数

* 35-3. 避免将函数的参数作为工作变量

* 35-4. 使用const防止指针类型的输入参数在函数体内被意外修改

### 建议36： 没有返回值的函数应声明为void类型

### 建议37： 确保函数体的“入口”与“出口”安全性
	
* 37-1. 尽量在函数体入口处对参数做有效性检查

		```
			char *Strncopy(char *dest,const char *src,size_t size){
				assert( (dest != NULL) && (src != NULL) );
				...
			}
		```

* 37-2. 尽量在函数体出口处对return语句做安全性检查

### 建议38： 在调用函数时，必须对返回值进行判断，同时对错误的返回值还要有相应的错误处理

### 建议39： 尽量减少函数本身或者函数间的递归调用

为什么要减少递归调用，因为递归的实现就是每个函数在每个执行的过程中都有自己的形参和局部变量的副本，因此会占用大量的空间。

**递归方便了程序员但是递归可以通过数学公式很方便的转化为程序，优点是便于理解，容易编程**

### 建议40： 尽量使用Inline内联函数代替#define宏

原因如下：

* 不使用函数是因为函数会占用大量的空间
* **不使用宏是因为宏不便于调试**
* C99已经支持inline函数的使用
* 
# <center>第5章：不会使用只指针的程序员是不合格的</center>

### 建议41： 理解指针变量的存储实质

* 指针类型：
	
	从语法的角度看，只要把指针声明的语句里的指针名字去掉，剩下的部分就是这个指针的类型。这是指针本身所具有的类型。

	如下面的代码所示：
		
		int * p	//指针的类型是Int*
	
		int **p	//指针的类型是int **
	
		int (*p)[3]	//指针的类型是int(*)[3]
		
	从语法上看，只需要将指针声明的语句中的指针名字和名字左边的指针声明符*去掉，剩下的就是指针所指向的类型。
			
		int *p;	//指针所指向的类型是int
		
		char *p	//指针所指向的类型是char
			
		int **p	//指针所指向的类型是int*
			
		int (*p)[3]	//指针所指向的类型是int ()[3]
		
		int *(*p)[4]	//指针所指向的类型是int *()[4]

### 建议42： 指针变量必须初始化

### 建议43： 区别"int * p = NULL"和"*p = NULL"

区别就是一个申请一个指针并初始化位NULL另一个是将指针所指向的变量设为0

### 建议44： 理解空(null)指针与NULL指针

1. 区别空(null)指针与NULL指针的概念
2. 用NULL指针终止对递归数据结构的间接引用
3. 用NULL指针作函数调用失败的返回值
4. 用NULL指针作为警戒值
5. 避免对NULL指针进行解引用

### 建议45： 谨慎使用void指针
1. 避免对void指针进行算术操作
		
	对于void指针，编译器并不知道所指对象的大小所以对void指针进行算术操作都是不合法的
	
		void *p
		p++;
		p+=1;
	
2. 如果函数的参数可以是任意类型的指针，应该将其参数声明位void*

### 建议46： 避免使用指针的长度确定它所指向的类型的长度
### 建议47： 避免将指针转换为对齐要求更严格的指针类型

如果将一种类型的指针存储或转换为void指针，然后再将void指针存储或转换位另一类型的指针，对象的对齐很可能会发生变化。

### 建议48： 避免将一种类型的操作符应用于另一种不兼容的类型
### 建议49： 谨慎指针与指针之间的转换

强制将指针类型转换位整数类型，或者将整数类型转换为指针类型，这些都不是良好的编程习惯。

### 建议50： 区别"const int *p"和"int *const p"

先从const int i与int const i之间的区别和概念说起；以上两者间的概念完全相同，const和int哪个写在前面都不影响语义。

然后再进行const对指针变量的影响；

首先第一个const修饰的是指针指向的变量而不是p所以*p是不可以改动的也就是它指向的变量是不能更改的；而对于第二种情况

p = &i2 这样是错误的

但是*p = ..是正确的

也就是指针变量固定了但是指针指向的变量的值能够更改

### 建议51： 深入理解函数参数的传递方式

1. 理解函数参数的传递过程（涉及到堆栈的调用）
2. 掌握函数的参数传递方式
	* 值传递
	* 地址传递
3. 如果函数的参数是指针，避免用该指针去申请动态内存
4. 尽量避免使用可变参数

	标准C语言中定义了一个头文件stdarg.h，专门用来对付可变参数列表

# <center>第6章：数组并非指针</center>

### 建议52： 理解数组的储存实质

1. 理解数组的储存布局
2. 理解&a[0]和&a的区别
3. 理解数组名a作为右值和左值的区别
	
### 建议53： 避免数组越界

1. 尽量显式的指定数组的边界
2. 对数组做越界检查，确保索引值位于合法的范围之内
3. **获取数组的长度时不要对指针应用sizeof操作符(面试必考)**

	对于数组int a[5],sizeof(a)可以获取数组的长度，使用sizeof(a[0])来获取数组元素的长度
	
		```
		#include<stdio.h>
		
		void Init(int arr[]){
			size_t i = 0;
			printf("sizeof(arr):%d\n",sizeof(arr));
			printf("sizeof(arr[0]):%d\n",sizeof(arr[0]));
			
			for(i = 0;i<sizeof(arr)/sizeof(arr[0]);i++){
				arr[i] = i;
			}
		} 
		int main(void){
			int i = 0;
			int a[10];
			printf("sizeof(a):%d\n",sizeof(a));
			Init(a);
			for(i = 0;i<10;i++){
				printf("%d\n",a);
			}
		}
	
		```


### 建议54： 数组并非指针

当我们使用extern进行声明的时候要注意将变量的类型也要表示出来。

### 建议55： 理解数组与指针的可交换性
1. 表达式中的数组名就是指针（是首地址）
2. 数组下标就是指针的偏移量
3. 函数形参的数组名被当作指向
4. 第一个元素的指针

### 建议56： 禁止将一个指向非数组对象的指针加上或减去一个整数（越界访问）
### 建议57： 禁止对两个并不指向同一个数组的指针进行相减或比较
### 建议58： 若结果值并不引用合法的数组元素，不要将指针加上或减去一个整数
### 建议59： 详细了解缓冲区溢出
一般一个程序中包含以下几个部分：

	堆栈段（栈stack 堆heap）
	数据段(非初始化数据段.bss  初始化数据段.data)
	文本（代码）段(.text)

代码段(.text)存放着程序的机器码和只读数据，可执行指令就是从这里取得的。如果可能，系统会安排好相同程序的多个运行实体共享这些实例代码。这个段再内存中一般被标记为只读，任何对该区的写操作都会导致段错误(Segmentation Fault)

堆栈段分为堆(heap)和栈（Stack）.堆用来存储程序运行时分配的变量；而栈则是一种用来存储函数调用时的临时信息结构。

**堆和栈的区别：**

1. 分配和管理方式不同
	
	堆是动态分配的，其空间的分配和释放都是由程序员控制。也就是说，堆的大小并不固定，可动态扩张或缩减，其分配由malloc()等这类实时内存分配函数来实现。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被删除（堆被缩减）

	而栈是由编译器自动管理，其分配方式有两种：静态分配和动态分配。静态分配由编译器完成，比如局部变量的分配。动态分配由alloca()函数进行分配，但是栈的动态分配和堆是不同的，它的动态分配是由编译器进行释放无需手工控制

2. 产生碎片不同
	
	对堆来说，频繁执行malloc或者free势必会造成内存空间的不连续，形成大量的碎片，使程序运行效率降低，而对于栈而言则不存在碎片问题。

3. 内存的增长方向不同

	堆是向着内存地址增长的方向增长的，从内存的低地址向高地址方向增长

	而栈的增长方向则刚好相反

### 建议60： 区别指针和数组指针
### 建议61： 深入理解数组参数

# <center>第7章：结构、位域和枚举</center>

##### c语言中，除提供基本的数据类型之外，还允许使用结构体、位域、联合、枚举与typedef关键字来定义自己的新类型。

### 建议62： 结构体的设计要遵循简单、单一的原则
1. 尽量使结构体的功能单一
2. 尽量减小结构体间关系的复杂度
3. 尽量使结构体中的元素的个数适中
4. 合理划分与改进结构体以提高空间效率

### 建议63： 合理利用结构体内存对齐原理来提高程序效率

**内存对齐作为一种强制要求**一方面简化了处理器与内存之间的传输系统的设计，另一方面可以提升读取数据的速度。常见的情况是：如果不按照适合其平台要求对齐数据存放进行对齐，会在存取效率上带来损失。比如在32位CPU上，一般要求变量地址都是基于4位的这样可以保证CPU用一次读写周期就可以读取变量，**如果不按照4字节对齐那么CPU就需要两个周期才能读取数据**。

一般编译器上都有默认的字节对齐功能，但是我们能够使用#pragma pack(n),n代表对齐模数，它可以是1，2，4，8等，编译器将按照n个字节对齐。使用伪指令#pragma pack()，取消自定义字节对齐方式，即将上一次#pragma pack(n)的设置取消，恢复默认值。

### 建议64： 结构体的长度不一定等于各个成员的长度之和
### 建议65： 避免在结构体之间逐行逐字节比较
### 建议66： 谨慎使用位域
	
比较简单的一个使用实例：

	struct Status_Type{
		unsigned cts:4;
		/*空域*/
		unsigned :0;
		/*从下一单元开始存放*/
		unsigned dsr:4;
		unsigned edg:4;
		unsigned rec:4;	
	}Status;

在这个位域定义中，cts占第一个字节的4位，后4位填0表示不使用。而dsr从第二字节开始，占用4位，edg占用4位，rec占用4位。

### 建议67： 谨慎使用枚举

如果直接将数值直接赋予枚举变量，那就错误了。

### 建议68： 禁止在位域成员上调用offsetof宏
### 建议69： 深入理解结构体数组和结构体指针
	
# <center>第8章：字符与字符串</center>

### 建议70： 不要忽视字符串的null（'\0'）结尾符
1. 正确的认识字符数组和字符串
2. 字符数组必须能够同时容纳字符数据和null结尾符
3. 谨慎字符数组的初始化
### 建议71： 尽量使用const指针来引用字符串常量
### 建议72： 区别strlen函数与sizeof运算符
	
strlen是一个函数，它用来计算指定字符串str的长度，但不包括结束字符(即null字符)

其原型是：

	size_t strlen(char const *str);

注意其返回类型是size_t，如果这样写就会造成错误：

	if(strlen(x)-strlen(y) >= 0){
		...
	}

这个判别式永远不可能错误，是因为size_t类型不可能存在负值

### 建议73： 在使用不受限制的字符串函数时，必须保证结果字符串不会溢出内存
1. 避免字符串拷贝发生溢出
	
	**char \* strcpy(char \*dest,const char \*src);**
	
	必须保证dest有足够的空间容纳要复制的src如果src过长而参数dest的空间不够通常会造成程序发生segmentation fault错误**(这个函数在我们日常的程序中比较常用)**。

	当然也可以使用

	**char \*strncpy(char \*dest,char \*src,size_t len);**

	进行替代，这个函数更加安全

2. 区别串拷贝strcpy与内存拷贝memcpy

	对于C语言的内存拷贝函数，memcpy函数应该是使用和面试频率最高的一个函数。

	原型**void \* memcpy(void \*dest,void \*src,size_t len);**

	表示从源src所指的内存地址的起始位置开始复制len个字节到目标dest所指的内存地址的起始位置中。**如果两个地址存在重叠，则最终行为未定义**

3. 避免strcpy与memcpy函数内存重叠

		```
		char *Strcpy(char *dest,const char *src){
			assert(dest != NULL && src != NULL);
			char *strDest = dest;
			while((*strDest++=*src++)!='\0');
			return dest;
		}

		void *Memcpy(void *dest,const void *src,size_t len){
			assert(dest != NULL && src != NULL);
			char *temp_dest = (char *)dest;
			char *temp_src = (char *)src;
			while(len--){
				*temp_dest ++ = *temp_src++;
			}
			return dest;
		}

		//这里两个函数并没有考虑到复制的时候的源地址和目的地址重合的情况
		//可以使用if( (src<dest)&&( (char*)src+size>dest ) )解决重合问题
		```

4. 区别字符串比较与内存比较
	1. 字符串比较
		函数原型：
		
		int strcmp(const char *s1,const char *s2);
				
			```
			
			int strcmp(p1,p2) const char* p1;const char *p2;
			{
				register const unsigned char *s1 = (const unsigned char *)p1;
				register const unsigned char *s2 = (const unsigned char *)p2;
				unsigned char c1,c2;
				do{
					c1 = (unsigned char)*s1++;
					c2 = (unsigned char)*s2++;
					if(c1 == '\0')
						return c1-c2;
				}while(c1 == c2);

				return c1-c2;

			}
			
				
			```
	2. 内存比较函数

		函数原型：
	
		int memcmp(const void *s1,const void *s2,size_t n);
		
		相对于strncmp函数，memcmp函数用于比较内存区域s1和s2的前n个字节。同理，

		当s1小于s2时，函数返回小于0的值；当s1等于s2时，函数返回0；当s1大于s2时，函数返回大于0的值。

		函数过长不展示

	3. 关于两者的不同的地方的总结
		
		**比较对象不同**
			strcmp函数只能比较两个字符串但是**memcmp**函数能够比较任意的对象

				```
					struct Point{
						int x;
						int y;
					}p = {3,5};
					int main(){
						struct Point p1 = {3,5};
						if(!memcmp(&p,&p1,sizeof(p))){
							printf("p == p1");
						}
						return 0;
					}

				```
5. 避免strcat函数发生内存重叠与溢出
	
	对于字符串的处理中，函数strcat可以把src指向的字符串(包括终止的空字符null('\0'))的副本添加到dest指向的字符串末尾。同时,src的第一个字符覆盖dest末尾的空字符串null('\0').

	函数原型：**char \* strcat(char \*dest,const char \*src);**

		char *strcat(dest,src) char *dest;const char *src;
		{
			char *s1 = dest;
			const char *s2 = src;
			char c;
			/*Find the end of the string.*/
			do
			c = *s1++;
			while(c != '\0');

			/*Make s1 point before the next charater,so we can increment it while
			
			memory is read (wins on pipelined cpus).
			*/

			s1 -= 2;
			do{
				c = *s2++;
				*++s1 = c;
			}while(c != '\0');
				
			return dest;

		}

	注意：在使用这个函数的时候，必须避免src与dest所指的内存区域发生重叠的情况，否则如果发生这种情况则属于未定义。**其次**必须保证dest有足够的空间来容纳src的字符串，从而避免发生缓冲区溢出

	另外还有经常使用的一个比较安全的函数是：

	**char \* strncat(char \*dest,const char \*src,size_t n);**

### 建议74： 谨慎strtok函数的不可重入性

对于字符串分割函数strtok，这个函数功能很大，争议也很大。

* 函数原型：

	**char \*strtok(char \*s,const char \*delim);**
	
	其中，tok是Token的缩写，分割出来的每一个字段字符串称为一个Token。参数s是待分割的字符串，delim是**分隔符**可以指定一个或者多个分隔符，strtok遇到其中任何一个分隔符就会分割字符串。

* 使用方法：

	当**首次调用strtok函数时，s指向要分解的字符串，之后再次调用时需要将s设为NULL**。也就是说，在首次调用strtok函数时，首先过滤掉所有属于分割字符串集合中的字符，然后进行扫描并将之后碰到的属于分割字符串集合中的字符使用空结束符null('\0')来替代，这样就可以使用该函数返回的值来直接读取第一个Token，之后获取剩下的Token，此时直接向strtok函数传递NULL作为第一个函数，从而不断的取得下一个Token。

* 实例代码：

	```
		int main(void){
			char str[] = "root:x::0:root:/root:/bin/bash:";
			char *token;
			token = strtok(str,":");
			printf("%s\n",token);
			while( (token = strtok(NULL,":")) != NULL ){
					printf("%s\n",token);
			}
			return 0;
		}	
		//这个函数只是在首次传入了字符串地址，之后不再需要，因为内部
		//内部使用了局部静态变量。函数过长不再列出
	```

### 建议75： 掌握字符串查找技术

1. 使用strchr与strrchr函数查找单个字符
	
	* 函数原型：
	
		**char \* strchr(const char \*s,int c);**;
		
		从左向右在字符串s中寻找字符c
		
		**char \*strrchr(const char \*s,int c);**;
		
		从右向左在字符串s中寻找字符c
		
	* 具体使用：
	
			int main(void){
				char str[] = "I welcome any ideas from readers,of course.";
				char *lc = strchr(str,'o');
				printf("strchar:%s\n",lc);
				char *rc = strrchr(str,'o');
				printf("strrchr:%s\n",rc);
				return 0;
			}
		
			//输出结果：
			//strchr:ome any ideas fromm readers,of course
			//strrchr:ourse.

2. 使用strpbrk函数查找多个字符

	* 函数原型：
	
		**char \*strpbrk(const char \*s1,const char \*s2);**
	
	* 作用:
		在源字符串s1中按从前到后顺序找出最先含有搜索字符串(s2)中任一字符的位置并返回，空字符null('\0')不包括在内，若找不到则返回空指针。
	
	* 函数实现：
	
			char *strpbrk(s,accept)
				const char *s;
				const char *accept;
			{
				while(*s != '\0'){
					const char *a = accept;
					while(*a != '\0')
						if(*a++ == *s)
							return (char *)s;
					++s;
				}
				return NULL;
			}

3. 使用strstr函数查找一个子串

	函数原型：
	
	**char \*strstr(const char \*haystack,const char \*needle);**
	
	作用：strstr函数表示在字符串haystack中从前到后查找子串needle第一次出现的位置（不比较结束符null（'\0'）），并返回指向第一次出现的needle位置的指针，如果没有找到就返回NULL。

4. 区别strspn与strcspn函数

	* 函数原型：
	
		**size_t strspn(const char \*s,const char \*accept);**
	
	* 作用：
		
		strspn函数表示从字符串s的第一个字符开始，逐个检查字符与字符串accept中的字符是否相同，如果不同，就停止检查，并返回以字符串s开头连续包含字符串accept内的字符数目。
	
	* 函数原型：
	
		**size_t strcspn(const char \*s,const char \*reject);**
	
	* 作用：
	
		相对于strspn函数，strcspn函数与之相反，它表示从一个字符串s第一个字符开始，逐个检查字符与reject中的字符是否相同，如果相同，则停止检查，并返回以字符串s开头连续不含字符串reject内的字符数目。

# <center>第9章：文件系统</center>

### 建议76： 谨慎使用printf和scanf函数
1. 使用printf
	* 类型符

		d、i  整型输出
	
		u    unsigned int 以无符号整型输出

		o    unsigned int 以八进制无符号整型输出

		x    unsigned int 以十六进制小写输出

		X    unsigned int 以十六进制大写输出

		f、F  double       以小数表示float和double型数据

		e    double       以科学计数法表示float和double型数据(e小写)

		E    double       以科学计数法表示float和double型数据(E大写)

		g    double       自动将能显示的很小或者很大的数转换成%f，不能直接显示的数则转化为%e

		G    double       ...

		a    double       浮点数、十六进制数字和p-计数法，字母小写(C99)

		A    double       ...

		c    int          单个字符

		s    字符串        字符串

		p    void*         内存地址，以十六进制表示

		%n是比较特殊的一个；当在格式化字符串中碰到"%n"时，在%n之前输出的字符个数会保存到下一个参数里。（注意：%n返回的是应该被输出的字符数目，而不是实际输出的字符数目。）

	* 标志符（用来控制输出的数字）
	* 宽度（控制显示数值的宽度）
	* 精度（控制显示数值的精度，对输出的是数字还是字符有不同的处理方法）
	* 长度（控制显示数值的长度）
2. 使用scanf函数

	函数功能刚好与printf函数相反，但是更加简单。即scanf函数从格式串的最左端开始，每遇到一个字符便将其与下一个输入字符进行“匹配”，如果二者匹配（相同）则继续，否则结束对后面的输入的处理。而每遇到一个格式说明符，便按该格式说明符所描述的格式对其后面的输入值进行转换。

### 建议77： 谨慎文件打开操作

因为同时打开多个文件操作的时候可能会出现文件缓冲区问题。

1. 正确指定fopen的mode参数

	mode的取值表（在这里省略...）

2. 必须检查fopen函数的返回值

	对于fopen函数，在使用的时候一定要检查该函数的返回值。如果文件打开失败，则会返回一个NULL值，同时将错误代码保存到errno中。如果程序不检查这种错误，会将这个NULL指针传给后续的I/O函数。

3. 尽量避免重复打开已经打开的文件

	因为对于有的平台来讲这么做是允许的但是有的平台这么做是不允许的。

4. 区别fopen与fopen_s函数

	* fopen_s函数原型：

		**errno_t fopen_s(FILE \*\*file,const char \* filename,const char \*mode)；**

	* 函数使用：

		如果正常打开文件其返回值是0，否则为错误码。			

		fopen函数打开的文件是能够共享的，也就是说在使用这个函数打开某个文件之后，别的函数也能打开相应的文件，并进行相应的操作这就埋下了安全隐患。而fopen_s函数则不支持问价的共享也就是说一旦使用fopen_s打开某个文件后，别的函数就不可能再打开这个文件了。

5. 区别fopen与freopen函数

	* freopen函数原型：

		**FILE \* freopen(const char \* filename,const char \*mode,FILE \*stream)；**

	* 函数作用：
	
		相对于fopen函数，freopen函数主要用于将标准输入/输出流（stdin:标准输入流，stdout:标准输出流，stderr：标准错误输出流）重定向到文件中。如果成功重定向文件流，建辉返回一个filename所指定文件的指针，否则返回NULL。

	* 示例代码：
	
			/*输入重定向，输入数据将从in.txt文件中读取*/
			freopen("in.txt","r",stdin);
			/*输出重定向，输出数据将保存在out.txt中*/
			freopen("out.txt","w",stdout);	

### 建议78： 文件操作完成后必须关闭	
### 建议79： 正确理解EOF宏

EOF是End of File的缩写，在C语言标准库中定义如下：

	\#define EOF (-1)

	在32位系统中-1表示为0xFFFFFFFF,所以EOF并不是一个字符。

### 建议80： 尽量使用feof和ferror检测**文件**结束和错误
### 建议81： 尽量使用fgets替代gets函数
gets函数由于不检查输入的字符长度会容易被溢出攻击
### 建议82： 尽量使用fputs替换puts函数（fputs主要用于对指定文件进行写入操作）
### 建议83： 合理选择单个字符读写函数
1. getchar putchar(主要用于标准流)
2. getc putc（主要用于文件）
3. fgetc fputc3
### 建议84： 区别格式化读写函数
1. 区别printf/scanf,fprintf/fscanf,sprintf/sscanf
	printf/scanf是我们已知的

	标准流：

		stdin	标准输入
		stdout	标准输出
		stderr	标准错误
		stdprn	标准打印机
		stdaux	标准串行设备

	示例详解：
		
		语句printf(...);实际相当于fprintf(stdout,...);

	**关于sprintf与sscanf:**sprintf和sscanf主要用于处理和分析字符串

	* sprintf主要用于格式化字符串、进制之间转换与连接字符串等
		
			const char *s1 = "hello";
			const char *s2 = "world";
			char str[100];
			int i = 256;

			/*将i转化为字符串*/
			sprintf(str,"%d",i);

			/*将i转化为16进制*/
			sprintf(str,"0x%X",i);
			/*连接字符串s1和s2*/
			sprintf(str,"%s  %s",s1,s2);

	* sscanf函数是将参数s的字符串根据参数format字符串来转换并格式化数据，转换后的结果存储在对应的参数内
	
			/*取仅包含1到8和小写字母的字符串*/
			sscanf("*1234567abdcdefghABCDEF","%[1-8a-z]s",str);

			/*取遇到大写字母为止的字符串*/
			sscanf("0123456789abcdedfghABCDEF","%[^A-Z]s",str);

2. 尽量使用snprintf替代sprintf（安全问题）
3. 区别vprintf/vscanf、vfprintf/vfscanf、vsprintf/vsscanf和vsnprintf

	前缀加个v表示这个函数是可变参数的

### 建议85： 尽量使用fread与fwrite函数来读写二进制文件

* 函数原型：

	**size_t fread(void \*buf,size_t size,size_t count,FILE \*fp);**

	**size_t fwrite(const void \*buf,size_t size,size_t count,FILE \*fp);**

count的意思是fp指针的位置移动count个数

对文件格式化读取函数fprintf与fscanf而言，尽管它可以从磁盘文件中读取任何类型的文件，即读写的文件类型可以是文本文件，二进制文件，也可以是其他形式的文件。但是对于二进制文件来讲，考虑到文件的读写效率原因，还是建议尽量使用fread和fwrite函数进行读写操作。

### 建议86： 尽量使用fseek替代rewind函数

对于文件的定位可以通过rewind fseek ftell函数来完成。

1. rewind函数将文件内部的位置指针重新指向一个流（数据流或者文件）起始的位置。

	函数原型：
	
	void rewind(FILE *fp);

2. fseek函数功能更加强大，它用来设定文件的当前读写位置，从而可以实现任意顺序访问文件的不同位置，以实现文件的随机访问。

	* 函数原型：
	
		int fseek(FILE *fp,long offset,int from);
	
		如果函数执行成功，fp将指向以from为基准，偏移offset个字节位置，函数返回值为0；如果函数执行失败（比如offset超过文件大小），则不改变fp指向的位置，函数的返回值为-1，并设置errno的值，可以用perror函数来输出错误信息。
	
	* from参数取值表
	
		文件首 ：SEEK_SET  0
		当前位置：SEEK_CUR  1
		文件末尾：SEEK_END  2
	
	* 几个使用示例：
	
			/*将读写位置移动到离文件开头100字节处*/
			fseek(fp,100L,0);
			/*将读写位置移动到离文件当前位置100字节处*/
			fseek(fp,-100L,1);
			/*将读写位置退会到离文件结尾100字节处*/
			fseek(fp,-100L,2);
			/*将读写位置移动到文件的起始位置*/
			fseek(fp,0L,SEEK_SET);
			/*将读写位置移动到文件尾*/
			fseek(fp,0L,SEEK_END);  = rewind函数

### 建议87： 尽量使用setvbuf替代setbuf

以上两个函数用来设置计算机在写入文件时候的缓冲区大小

* 函数原型：

	**void setbuf(FILE \*fp,char \*buf);**
	
	**int setvbuf(FILE \*fp,char \*buf,int mode,size_t size);**

* 使用：

	使用setbuf与setvbuf函数指定文件的缓冲区一定要在文件读写之前。一旦用户自己指定了文件的缓冲区，文件的读写就要在用户指定的缓冲区中进行，而不是系统默认指定的缓冲区中进行。
	
	setbuf(fp,NULL)；//这个语句就是使文件不带IO缓冲

* 注意:

	对于setvbuf函数，则由malloc函数来分配缓冲区，参数size指明了缓冲区的长度（必须大于0）,而参数mode则表示函数缓冲的类型，取值如下表：
	
		_IOFBUF    全缓冲
		_IOLBF	   行缓冲
		_IONBF     不缓冲，此时忽略buf与size参数的值，直接读写文件，不再经过文件缓冲区缓冲

### 建议88： 谨慎remove函数删除已经打开的文件

当我们确实要删掉一个已经打开的文件，应该尽可能使用相应的平台上支持该功能的函数。

### 建议89： 谨慎rename函数重命名已经存在的文件

* 函数rename的函数原型：
		
	**int rename(const char \*oldfilename,const char \* newfilename);**

	因为不同平台上定义的行为不相同（更加具体的解释见书上）。

# <center>第10章：预处理器</center>

### 建议90： 谨慎宏定义
1. 在使用宏定义表达式时必须使用完备的括号
	
	原因对于函数而言，宏只是简单的字符替换。但是，在进行宏替换的时候，如果不使用括号保护各个宏参数，那么将很可能产生意想不到的情况

2. 尽量消除宏的副作用

	在c语言中，宏定义可以简单的划分为**有参数**和**无参数**两类。而对于有参数的宏，虽然与函数有几分相似，但是却容易产生副作用，引发起许多难以预料的问题。

3. 避免使用宏创建一种“新语言”

### 建议91： 合理地选择函数与宏

宏的一个特殊功能：可以把参数类型传递给带参的宏

### 建议92： 尽量使用内联函数代替宏

示例：

	inline int imax(int a,int b){
		return a>b?a:b;
	}

宏定义只是简单的字符串替换，不具备像函数那样完备的参数检查能力。

在C99标准中，inline函数一般只在当前的c文件能展开；所以如果想要在别的文件中使用这个函数的时候应该将这个文件写到.h文件中，这样在别的文件中如果想要使用这个文件只需要包含这个头文件就可以了。

### 建议93： 掌握预定义宏

常用的标准预定义宏

	_DATE_			当前源文件的编译日期
	_FILE_			当前源文件的名称，常用字符串常量表示
	_LINE_			当前源文件中的行号
	_TIME_			当前源文件的最新编译时间
	_STDC_			如果当前编译器符和ISO标准,那么该宏的值为1，否则未定义

	_STDC_VERSION_
	_STDC_HOSTED_
	_STDC_IEC_559_
	_STDC_IEC_559_COMPLEX_
	_STDC_ISO_10646_

有了以上定义的宏我们可以通过编译器知道程序编译的时间，并且可以通过相关的宏定位代码在运行的时候的错误位置。

### 建议94： 谨慎使用"#include"

在C语言中，文件包含指令(#include)的功能是把指定的文件插入到该命令行位置以取代该命令行，从而把指定文件和当前的源程序连接成一个源文件

1. 区别"#include<filename.h>"与"#include"filename.h""
2. 必须保证头文件名称的唯一性

### 建议95： 掌握条件编译指令
1. 使用"#ifndef/#define/#endif"防止头文件被重复引用

	在C语言中，一个文件可以包含多个头文件，而头文件之间又是可以相互引用的，这将引起一个文件中可能间接多次包含某个头文件，从而导致了某些头文件被重复引用多次。

	解决方案：

		#ifndef _HEADERNAME_H_
		#define _HEADERNAME_H_

		/*声明、定义语句*/

		#endif

	通过这个结构能产生预处理块，虽然能够避免同一个头文件被多次包含和重复引用，但是也存在一个致命的缺点，那就是一旦一不小心不同的头文件中定义了相同的宏名，问题就比较麻烦了。比如可能会导致明明看到存在头文件，而编译器却硬说找不到声明等问题。Google的建议是**头文件基于其所在的项目源代码树的全路径进行重命名**

2. 使用条件编译指令实现源代码的部分编译

	条件编译指令可以使编译器按不同的条件编译不同的程序部分，因而产生不同的目标代码文件。这对于跨平台移植程序是非常有必要的。

	常用的指令：



		#if  该指令检测表达式是否为真

		#endif	该指令用于终止#if指令

		#else	用于#if指令之后，当前面的#if指令的条件不为真时就编译else后面的代码

		#elif	...

			示例：

			#if OS == 1
				printf("V1.0");
			#elif OS == 2
				printf("V2.0");
			#else
				printf("未知");
			#endif
	
		#ifdef与ifndef指令

			示例：

			#ifdef 宏名称
				/*程序段1*/
			#else
				/*程序段2*/
			#endif

			示例：

			#ifndef 宏名称
				/*程序段1*/
			#else	
				/*程序段2*/
			#endif

### 建议96： 尽量避免在一个函数块中单独使用"#define"或"#undef"
	
在C语言中，"#undef"指令与"#define"刚好相反，它用于**取消宏定义**，在使用"#undef"指令取消一个宏定义之后，该宏定义便失效，但是可以重新使用"#define"进行定义.

注意：如果在代码中要重新定义宏，应该先用"undef"解除前面的定义。于此同时，尽量避免在一个函数块中单独使用"#define"或"undef"指令。

# <center>第11章：断言与异常处理</center>

对于可以预料的异常情况，在进行程序设计时，都应该提前规划好处理办法，把功能模块代码与系统中可能出现的异常的处理代码分离开，编制相应的预防代码或者处理代码，以防止异常发生后造成严重后果。这样程序除了要保证其正确性之外，还要具有一定容错能力，即使在应用环境出现意外或者用户操作不当时，也要有合理的处理结果。

### 建议97： 谨慎使用断言

在C语言中，断言被定义为宏的形式(assert(expression))，而不是函数，其原型定义在<assert.h>文件中。其中，assert将通过检查表达式expression的值来决定是否需要终止执行程序。**也就是说，如果表达式expression的值为假（即为0），那么它将首先向标准错误流stderr打印一条错误信息然后再通过调用abort函数终止程序运行，否则，assert无任何作用**

**注意：**默认情况下，assert宏只有再Debug(内部调试版本)中才能起作用，而再Release版本(发行版本)中将被忽略。

1. 尽量利用断言来提高代码的可测性

	示例：
		
		void *MemCopy(void *dest,const void *src,size_t len){
			assert(dest != NULL && src != NULL);
			char *temp_dest = (char *)dest;
			char *temp_src = (char *)src;
			while(len--){
				*temp_dest++=*temp_src++;
			return dest;
			}
	
		}

2. 尽量在函数中使用断言来检查参数的合法性

	示例:

		void *Memcpy(void *dest,const void *src,size_t len){
			assert(dest != NULL && src != NULL);
			char *temp_dest = (char *)dest;
			char *temp_src = (char *)src;

			/*检查内存块是否重叠*/

			assert(temp_dest>=temp_src || temp_src>=temp_dest+len);

			while(len--)
				*temp_dest++=*temp_src++;
			return dest;
		}
	
3. 避免在断言表达式中使用改变环境的语句

	示例:

		assert(i++);

4. 避免使用断言去检查程序错误

	在对断言的使用中，一定要遵循这样的规定：

	**对来自系统内部的可靠的数据使用断言，对于外部不可靠数据不能够使用断言，而应该使用错误处理代码。**换句话说，断言是用来处理不应该发生的非法情况，而对于可能会发生且必须处理的情况应该使用错误处理代码，而不是断言。

	示例：
	
		char *Strdup(const char* source){
			assert(source != NULL);

			char* result = NULL;
			size_t len =strlen(source)+1;
			result = (char *)malloc(len);
			
			assert(result != NULL);
			//这相当于将断言当作正常的函数使用！错误
		}

5. 尽量在防错性程序设计中使用断言来进行错误警报
6. 用断言保证没有定义的特性或者功能不被使用
7. 谨慎使用断言对程序开发环境进行假设
	
	在程序设计中，不能够使用断言来检查程序运行时所需的软硬件环境以及配置要求，他们需要由专门的处理代码进行检查处理。

### 建议98： 谨慎使用errno

在C语言中用于存放错误码的全局变量是errno，**为了防止和正常的返回值混淆，系统调用一般并不直接返回错误码，而是将错误码（是一个整数值，不同的值代表不同的含义）存入一个名为errno的全局变量中，errno不同数值所代表的错误消息定义在errno.h中。**如果一个系统调用失败或库函数调用失败，可以通过读出errno的值来确定问题所在，推测程序出错的原因。

配合perror和strerror函数，还可以很方便的查看出错的详细信息。其中，perror在stdio.h中定义，用于打印错误码以及消息描述；而strerror在string.h中定义，用于获取错误码对应的消息描述。

**注意：**并不是所有的可函数都适合使用errno全局变量。就errno而言，库函数一般分为如下几个类型。

   * 设置errno并返回一个带内"In-Band"错误指示符的库函数、
   * 设置errno并返回一个带外"Out-of-Band"错误指示符的库函数
   * 不保证设置errno的库函数
   * 具有不同标准文档的库函数
	
**使用时候的注意事项：**

1. 调用errno之前必须先将其清零
		
	示例：

		int main(void){
				/*调用errno之前必须先将其清零*/
				errno = 0;
				FILE *fp = fopen("test.txt","r");
				if(fp == NULL){
					if(errno != 0){
						printf("errno值：%d\n",errno);
						printf("错误信息：%s\n",strerror(errno));
					}
				}
		}

		//输出信息：
		//errno值：2
		//错误信息：No such file or directory

2. 避免重定义errno

3. 避免使用errno检查文件流错误

	在POSIX标准中，可以通过errno值来检查fopen函数调用是否发生了错误。但是，对于特定的文件流操作是否出错的检查则必须使用ferror函数。

### 建议99： 谨慎使用函数的返回值来标志函数是否执行成功

不要这样做的最主要的原因是：如果一个函数既需要返回内部的处理结果，又需要返回值来确认函数的执行成功与否，这样很容易造成返回值冲突问题。例如返回的结果可能刚好代表是函数执行错误。

### 建议100： 尽量避免使用goto进行出错跳转

### 建议101： 尽量避免使用setjmp和longjmp组合

# <center>第12章:内存管理</center>

### 建议102： 浅谈程序的内存结构


	未初始化数据段(.bss)								

	已初始化数据段(.data);

	代码段(.text)

	存储时的区域	

### 建议103： 浅谈堆和栈

1. 栈

	就是一个"先进先出"的储存结构。在实际编程中可以使用数组实现也可以使用链表实现。

2. 堆

	相对于栈的“先进后出”特性，堆则是一种经过排序的**树形数据结构**常用来实现优先队列等。

* 内存分配中的堆和栈：

	* 从静态存储区域分配：它是有编译器自动分配和释放的，即内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在，直到整个程序运行结束时才被释放，如全局变量和static变量。	
	* 从栈上分配：它同样也是由编译器自动分配和释放的，即在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元将被自动释放。需要注意的是，栈内存分配运算内置于处理器指令集中，它的运行效率一般很高，但是分配的内存容量有限。
	* 从堆上分配：也叫做动态内存分配，它是由程序员手动完成申请和释放的。即程序在运行的时候由程序员使用内存分配函数(如malloc函数)来申请任意多少内存。使用完之后再由程序员自己负责使用内存释放函数(如free函数)来释放内存。也就是说，动态内存的整个生存期是由程序员自己决定的，使用非常灵活。需要注意的是，如果在堆上分配了内存空间，就必须及时释放它，否则将会导致运行的程序出现内存泄漏等错误。


		**内存中的栈区主要用于分配局部变量空间，处于相对较高的地址，其栈地址是向下增长的；而堆区则主要用于分配程序员申请的内存空间，堆地址是向上增长的。**

* 内存中堆和栈的区别：

	1. 分配与释放方式

		栈内存是由编译器自动分配和释放的，它有两种分配方式：静态分配和动态分配。
	
		* 静态分配是由编译器自动完成的例如局部变量的分配（即在一个函数中声明一个int类型的变量i时，编译器就会自动开辟一块内存用来存放变量i）。与此同时，其生存周期也只在函数的运行过程中，在运行后就释放，并不可以再次访问。
	
		* 动态分配由alloca函数进行分配，但是栈的动态分配与堆是不同的，它的**动态分配是由编译器进行释放的**，无需任何手工实现。值得注意的是，虽然用alloca函数可以实现栈内存的动态分配，但alloca函数的可移植性很差，而且**在没有传统堆栈的机器上很难实现**。因此不宜使用于广泛移植的程序中。而且，**完全可以使用C99中的边长数组来代替alloca函数**。**而堆内存则不相同，它完全是由程序员手动申请于释放的**，程序在运行的时候由程序员使用内存分配函数(如malloc函数)来申请任意多少的内存，使用完再由程序员自己负责使用内存释放函数(如free函数)释放内存。对于栈内存的自动释放而言，**虽然堆上的数据只要程序员不释放空间就可以一直访问，但是，如果一旦忘记了释放堆内存，那么将会造成内存泄漏，导致程序出现致命的错误**。

	2. 分配的碎片问题

		对堆来讲，频繁分配和释放(malloc/free)不同大小的堆空间势必会造成内存空间的不连续，从而造成大量的碎片，导致程序效率低；而对于栈来讲，则不会存在这个问题。

	3. 分配的效率

		栈是机器系统提供的数据结构，计算机会在底层对栈提供支持，例如，分配专门得寄存器存放栈得地址，压栈出栈都有专门得执行指令，这就决定了栈得效率比较高，一般而言，**只要栈的剩余空间大于申请得空间，系统就将为程序提供内存，否则将报异常，提示栈溢出(?在使用alloca的时候会出现?在编译之前申请的空间不会出现错误?)**。

		而堆则不同，它是由C/C++函数库提供的，它的机制也是相当的复杂。例如，为了分配一块堆内存，首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆节点，然后将该节点从空闲节点链表删除，并将该节点的空间分配给程序。而对于大多数系统，会在这块内存空间的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确释放内存空间。另外，由于找到的堆节点的大小不一定正好等于申请的大小，系统会自动将多于的那部分重新放入空闲链表中，很显然，堆的分配效率比栈要低的多。

	4. 申请的大小限制

		由于操作系统是用链表来存储空闲内存地址（内存区域不连续）的，同时链表的遍历方向是由低地址向高地址进行的。因此，堆内存的申请大小受限于计算机系统中有效的虚拟内存。而栈则不同，它是一块连续的内存区域，其地址的增长方向是向下进行的，向内存地址减小的方向增长。由此可见，栈顶的地址和栈的最大容量一般都是由系统预先设定号得额，如果申请的空间超过栈的剩余空间时，将会提示溢出错误。由此可见相对于堆，能够从栈中获得的空间相对较小。

	5. 存储的内容

		对栈而言，一般用于存放函数的参数于局部变量等。

		对堆而言，具体存储内容由程序员根据需求决定存储数据。

		最后介绍一下C语言中个类型变量的存储位置和作用域

		* 全局变量：从静态存储区域分配，其作用域是全局作用域，也就是整个程序的生命周期内都可以使用。而且同extern关键字可以将这个变量分享给其他的文件使用。

		* 全局静态变量：从静态存储区域分配，其声明周期也是域整个程序同在，从程序开始到结束一直起作用。	**但是与全局变量不同的是，全局静态变量作用域只在定义它的一个源文件内，其他源文件不能使用**。

		* 局部变量：从栈上分配，其作用域只是在局部函数内，在定义该变量的函数内，只要出了该函数，该局部变量就不再起作用，该变量的声明周期也只是和该函数同在。

		* 局部静态变量：从静态存储区域分配，其在第一次初始化后就一直存在知道程序结束，**该变量的特点是其作用域只在定义它的函数内可见，出了该函数就不可见了**。

### 建议104： 避免错误分配内存

C语言主要提供malloc、realloc、calloc、alloca与aligned_alloc等内存分配函数来实现堆内存的分配功能。

1. 函数原型：
	* **void \*malloc(size_t size);**
	
	* **void \*calloc(size_t num,size_t size);**
	
		跟malloc作用类似不过是将申请到的内存全部初始化为0
	 
	* **void \*realloc(void \*ptr,size_t size);**
	
		检查之前申请的ptr指针的内存空间是否大于size如果大于将ptr的内存空间扩大到size大小内容不变；但是如果ptr指向的申请的内存片段没有那么大就重新从堆上申请一个内存并将ptr指向的内存中的内容复制到新申请的内存空间中，并返回新申请的指针变量。
	
	* **void \*alloca(size_t size);**
		对栈进行申请
	
	* **void \*aligned_alloc(size_t alignement,size_t size);**
		以对齐的方式进行申请，最像malloc，不会初始化申请的内存。

### 建议105： 确保安全释放内存

在使用完内存分配函数申请的内存空间后，一定要记得即使释放内存空间，否则就会出现内存泄漏等错误。其中，内存释放函数free原型如下：

**void \*free(void \*ptr);**

该函数用于释放指针ptr所指向的内存空间。如果ptr为NULL，或者指向不存在的内存块，将不做任何操作。

1. malloc等内存分配函数一定要与free函数配对使用

	注意申请和释放函数一定要成对出现，而且只能出现一个申请和一个释放对应的存在形式；不能出现一对多或者多对一；

2. 在free之后必须为指针赋一个新值

	释放内存后一定要将ptr指针指向NULL如果不设置为NULL那么当误调用到这个ptr指针的时候就会出现内存错误，导致程序崩溃。

### 建议106： 避免内存越界

内存越界是软件系统的主要错误之一，往往产生非常严重的后果。

一般情况下，内存越界访问可以分为如下两种：

* 读越界，即读到了不属于自己控制的数据；当读取的内存地址是无效的时候操作系统会让程序立刻崩溃；当读取到的程序是有效的时候由于读取到的数据是随机，所以这些随机数据将会使程序产生不可预料的后果。
* 写越界，又称为缓冲区溢出，所写入的数据对别的程序来说是随机的，它也会造成不可预料的后果。

常见的越界：

1. 避免数组越界
2. 避免sprintf,vsprintf,strcpy,strcat与gets越界

	前面已经讲过，C语言提供的字符串库函数sprintf,vsprintf,strcpy,strcat与gets等非常危险，很容易导致内存越界，应该尽量使用安全的字符串库函数snprintf,strncpy,strncat与fgets来替代它们。

	示例：

		char buf[250];
		sprintf(buf,"\*\*\* File:%s Line : %d \*\*\*",_FILE_,_LINE_);
		
	其中，“_FILE_”在预编译的时候，被编译时的目录名和源文件代替，但目录和文件的长度可变，很可能超过250个字节，从而导致内存越界。因此，应该使用snprintf来替换sprintf函数，**指定缓冲区的大小**，确保内存不会越界。

	示例：

		snprintf(buf,MAX_BUF_SIZE-1,".......");
		buf[MAX_BUF_SIZE-1] = '\0';

3. 避免memcpy与memset函数长度越界
4. 避免忽略字符串最后的'\0'字符而导致的越界（这种情况会导致在最后打印的时候出现很多奇怪的字符）

### 建议107： 避免内存泄漏

在堆上分配的内存，如果不再使用就应该及时释放，以便于后面其他的地方可以使用。在C语言中，内存管理器不会自动回收不再使用的内存。如果忘了释放不再使用的内存，这些内存就不能被重复使用，这就造成了**内存泄漏（简单的说就是没有接着使用已经申请的内存，造成了浪费）**。虽然在程序推出的时候操作系统会自动回收所有的内存但是如果在程序的运行过程中，泄漏了大量的内存就可能使进程的速度减慢**原因使体积大的进程更有可能系统换出让别的进行运行，而且大的进程在换进换出的时候花费的时间也会更多**

### 建议108： 避免calloc参数相乘的值超过size_t表示的范围

calloc函数 void \*calloc(size_t num,size_t size) 通过参数num乘以size来决定最终要分配的内存数。但是这个相乘得到的数字不能大于**SIZE\_MAX**；SIZE_MAX使标准C库定义的一个宏，它表示size_t的最大值。

# <center>第13章：信号处理</center>

信号（signal）是linux编程中非常重要的组成部分，全称为软中断信号，也可以简称为软中断（在软件层次上堆中断机制的一种模拟），其主要作用即使用来通知进程发生了异步事件。信号是进程间通信机制中唯一的异步通信机制，一个进程之间不必通过任何操作来等待信号的到来，事实上，进程也不知道信号到底什么时候到达。进程间可以相互通过系统调用kill发送软中断信号，内核也可以因为内部事件而给进程发送信号，通知进程发生了某个事件。

在通常情况下，进程在接受到信号之后，处理方式有如下3种：

1. 忽略信号：即进程可以通过代码显式的忽略某个信号，对该信号不做任何处理，就像从未发生过一样，如“signal(SIGINT,SIGDEF)”
2. 接收默认处理：即对该信号的处理保留系统的默认值。通常，接收默认处理的进程会导致进程本身的消亡。例如，连接到终端的进程，当用户按下CTRL+C将导致内核向进程发送一个SIGINT信号，如果进程不对该信号做特殊处理，系统将采用默认的方式处理该信号，即终止进程的执行。
3. 捕捉信号并进行处理：类似中断的处理程序，进程可以事先注册信号处理函数，当接收到信号时由信号处理函数自动捕捉并处理信号

在标准C库函数中文件signal.h是库中的信号处理部分，其中定义了程序执行时如何处理不同的信号。

### 建议109： 理解信号

简单的讲，信号事件的发生主要来源于如下两个方面：

	* 硬件来源：如按下了键盘或者其他硬件故障
	* 软件来源：如在Linux中用于发送信号的函数(如raise,kill,killpg,pthread_kill,tgkill与sigqueue函数)还包括一些非法运算等操作。

综合后可以归纳为以下几个方面：

	* 与进程终止相关的信号：如当进程退出或者子进程终止时，发出这类信号。
	* 与进程例外事件相关的信号：如进程越界或企图写一个只读的内存区域（如程序正文区），又或者是执行一个特权指令及其他硬件错误。
	* 与在系统调用期间遇到不可恢复条件相关的信号：如执行系统调用exec时，原有资源已经释放，而目前系统资源又已经耗尽。
	* 与执行系统调用时遇到非预测错误条件相关的信号：如执行一个并不存在的系统调用。
	* 在用户态下的进程发出的信号：如进程调用系统调用kill向其他进程发送信号。
	* 与终端交互的相关信号：如用户关闭一个终端，或者按下break键等情况。
	* 跟踪进程执行的信号。

一般情况下，信号定义在系统头文件signal.h中，每一个信号都用一个整型常量宏表示，以SIG开头，如SIGCHLD,SIGINT等。在标准C语言中，在signal.h头文件中定义了6个信号。

		SIGABRT			异常中止			
		SIGFPE			浮点异常
		SIGILL			无效指令
		SIGINT			交互的用户按键请求，默认情况下，这回导致进程终止
		SIGSEGV			无效的内存访问
		SIGTERM			程序的中止请求

除此之外，针对不同类型的操作系统，还定义了许多其他不同的信号，这主要依赖于具体实现。在Linux系统中，可以通过"kill -l"指令来获取所支持的信号列表。

		xuyongkang@ubuntu:~$ kill -l
		 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP
		 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1
		11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM
		16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP
		21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ
		26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR
		31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3
		38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8
		43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13
		48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12
		53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7
		58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2
		63) SIGRTMAX-1	64) SIGRTMAX	

另外还可以通过"man 7 signal"指令来查看更加详细的说明。

		表略

表中的“动作”列中的项目指出每个信号默认的处理方式，具体含义如下表：
		
		动作			描述
		Term		默认动作是终止相应的进程		
		Ign			默认动作是忽略相应的信号
		Core		默认动作是终止相应的进程并保存内存内存信息
		Stop		默认动作是停止行营的进程
		Cont		默认动作是如果当前进程停止则继续执行

表中所描述的标准信号中，他们都已经有了预定义值，每个信号有了确定的用途及含义，并且每种信号也都有默认的动作。例如，当点击键盘Ctrl+C时，就会产生一个SIGINT信号，对该信号的默认反应就是进程终止。

除此之外，Linux内核还支持32个实时信号（编程范围为33-64）。相对于表中的标准信号，实时信号还没有预定义的含义，整个实时信号集都可以用于用户自定义的目的。

**注意**：整个信号的处理过程涉及到用户态和内核态的相互转化。

### 建议110： 尽量使用sigaction代替signal

要对一个信号进行处理，就需要给出此信号发生时系统所调用的处理函数。可以对一个特定的信号（除去SIGKILL和SIGSTOP信号）注册相应的处理函数。注册某个信号的处理函数后，当进程接收到此信号时，无论进程处于何种状态，都会停下当前任务去执行此信号的处理函数。

在标准C语言库中，一个进程能够使用signal函数来改变一个信号的处理方式。它被定义在signal.h文件中，原型如下：

		#include<signal.h>
		void (*signal(int signum,void (*handler)(int)));

进一步变形为：

		typedef void (*sighandler_t)(int)
		sighandler_t signal(int signum,sighandler_t handler);

**函数signal的返回值类型同第二个参数handler，是一个指向某个返回值为空并带有一个整型参数的函数指针。正确返回之前的信号处理器，错误时返回SIG_ERR**

signal示例程序：

		#include<stdio.h>
		#include<signal.h>
		volatile sig_atomic_t sig1 = 0;
		volatile sig_atomic_t sig2 = 0;
		void handler(int signum){
			if(signum == SIGUSR1){
				sig1 = 1;
			}else if(sig1){
				sig2 = 1;
			}
		}
		int main(void){
			if(signal(SIGUSR1,handler) == SIG_ERR){
				/*...*/
			}
			if(signal(SIGUSR2,handler) == SIG_ERR){
				/*...*/
			}
			while(sig2 == 0){
					
			}
			
			return 0;
		}

这里的handler实现存在一个竞争条件。如果调用handler处理SIGUSR1,并且它被中断以处理SIGUSR2，从而就有可能导致sig2并未被设置。相对于标准C语言库中的signal函数，POSIX标准提供的sigaction函数则允许显示设置信号屏蔽。因此，函数sigaction可以用于防止信号处理函数中断自身。

函数sigaction原型如下：

	int sigaction(int signum,
				  const struct sigaction *act,
				  struct sigaction *oldact
				);

该函数的第一个参数signum为信号的值，可以为除SIGKILL及SIGSTOP外的任何一个特定有效的信号（为这两个信号定义自己的处理函数，将导致信号安装错误）；

第二个参数是指向结构sigaction的一个实例的指针，在结构sigaction的实例中指定了对特定信号的处理，若为NULL，进程会以默认方式对信号处理

第三个参数oldact指向的对象用来保存返回的原来对相应信号的处理，可指定oldact为NULL。

<关于这一段并没有全部摘录下来，等实际用到的时候再做说明>

### 建议111： 避免再信号处理函数内部访问或修改共享对象

在C语言中，应该尽量避免在信号处理函数内部访问或修改共享对象，否则将会导致竞争读写问题，从而引起数据状态的不一致。

### 建议112： 避免以递归方式调用raise函数

在C语言中，函数raise允许一个进程给它自己发送一个信号。但是，必须避免以递归方式调用raise函数。

# <center>第14章：了解C11标准</center>

2011年12月，ANSI正式采纳了ISO/IEC 9899：2011标准，即C11标准，它是C语言的现行标准。迄今为止，市面上的C语言编译器（如GCC,Clang，Intel C++ Compiler等）都只能部分支持C11标准的新特性。

### 建议113： 谨慎使用_Generic

对接触过面向对象程序涉及的程序员来讲，对泛型编程并不陌生。在C11标准中_Generic关键字可以让C语言也如同C++等面向对象程序设计语言一样，时期支持轻量级的泛型编程设计。

使用示例：

	#include<stdio.h>
	#include<string.h>
	#include<stddef.h>
	#include<stdint.h>

	#define getTypeName(x) _Generic((x),_Bool:"_Bool",\
		char :"char",\
		signed char:"unsigned char",\
		unsigned char:"unsigned char",\
		int:"int",\
		unsigned int:"unsigned int",\
	)

	int main(){
		char c = 'a';
		size_t s;
		int i;
		printf("c is '%s'\n",getTypeName(c));
		printf("s is '%s'\n",getTypeName(s));
		printf("i is '%s'\n",getTypeName(i));
		
	}

	//最终结果将输出某些变量的类型名。

### 建议114： 尽量使用get_s替换gets函数

* 函数原型：

	**char \*gets_s(char \*str,rsize_t n);**

	* 如果n等于0，或者n大于**RSIZE_MAX**，又或者是str指针为NULL，都将产生一个错误条件。如果产生了错误条件，那么将不会有任何的输入条件，str将不会被更改。
		
	* 该函数最多读入n-1个字符，并且在最后一个字符读入数组后立即在其后加上空字符。因此，如果指定的输入字符数超过目标缓冲区的长度，那么gets_s函数仍然可能导致缓冲区溢出等安全性问题。**那这个函数的意义何在？**
		
	* 如果函数执行成功，则返回str。**如果函数执行失败，则返回NULL，同时把缓冲区设置为空字符串，并清除输入流至下一个换行符**。

		char buf[100];
		if(gets_s(buf,sizeof(buf)) == NULL){
			//...
		}

### 建议115： 尽量使用带边界检查的字符串操作函数

在C语言中，不检查边界的字符串操作函数给程序带来了很大的安全隐患，C11附录K定义了一组带边界检查的函数接口进行替代。其中C11附录K的3.7节定义了:

	memcpy_s
	memmove_s
	strcpy_s
	strcat_s
	strncat_s
	strtok_s
	memset_s
	strerror_s
	strnlen_s

	分别替代
	
	memcpy
	memmove
	strcpy
	strcat
	strncat
	strtok
	memset
	strerror
	strnlen

### 建议116： 了解C11多线程编程

对于普通的C语言程序员来说,C11标准的最大改变应该算是对多线程编程的支持进行了标准化。尽管C11线程仅仅是一个“建议标准”，**目前市面上绝大部分C语言编译器也不支持该特性**。

在C11标准库中，**头文件<threads.h>**声明了:

* 创建和管理线程
* 条件变量
* 初始化
* 互斥对象于特定于线程的存储等函数

头文件**<stdatomic.h>**则声明了:

* 不可中断对象访问工具

最后，还引入了一个新的存储类修饰符_Thread_local，声明为_Thread_local的变量不在多线程之间共享，即每个线程持有变量的单独拷贝。

1. 线程的创建和管理

	函数原型：
	
	用于创建一个新线程func(arg)调用，新线程的标识符放在thr内
	
	**int thrd_create(thrd_t \*thr,thrd_start_t func,void \*arg);**
	
	用于判断两个线程标识符是否相等（即标识同一线程）
	
	**int thrd_equal(thrd_t lhs,thrd_t rhs);**
	
	返回调用线程的标识符
	
	**thrd_t thrd_current();**
	
	休眠当前线程
	
	**int thrd_sleep(const struct timespec \* time_point,
					struct timespec \* remaining);**
	
	让出CPU给其他线程或者进程
	
	**void thrd_yield();**
	
	终止当前线程
	
	**_Noreturn void thrd_exit(int res);**
	
	
	通知操作系统，当该线程结束时，负责回收该线程所占用的资源
	
	**int thrd_detach(thrd thr);**
	
	阻塞当前进程直至线程thr结束时才返回
	
	**int thrd_join(thrd_t thr,int \*res);**
	
	示例代码演示了线程的创建过程：
	
		int Test(void *val){
				int * result = (int*)val;
				printf("Result: %d\n",*result);  /*Correctly prints 1*/
				return 0;
		}
	
		void CreateThread(thrd *tid){
				static int val = 1;
				if(thrd_success != thrd_create(tid,Test,&val)){
					/*...*/
				}
		}
		int main(void){
			thrd_t tid;
			CreateThread(&tid);
			if(thrd_success != thrd_join(tid,NULL)){
				/*...*/
			}
			return 0;
		}

2. 互斥对象

	初始化互斥对象，type参数决定互斥对象的类型
	
	**int mtx_init(mtx_t \*mtx,int type);**

	**int mtx_lock(mtx_t \*mtx);**

	**int mtx_timedlock(mtx_t \*restrict mtx,const struct timespec \*restrict ts);**

	**int mtx_trylock(mtx_t \*mtx);**

	**void mtx_destroy(mtx_t \*mtx);**

	**int mtx_unlock(mtx_t \*mtx);**
	
	对于互斥对象的使用，只需要在使用mtx_init函数进行初始化时，指定该互斥对象的类型即可，一共有下面几种类型供选择。
	
	**mtx_plain:**简单的非递归互斥对象
	**mtx_timed：**非递归的，支持超时的互斥对象
	**mtx_plain|mtx_recursive:**简单的，递归互斥对象
	**mtx_timed|mtx_recursive:**递归的，支持超时的互斥对象
	
	函数**mtx_lock、mtx_timedlock与mtx_trylock**都可以对mtx互斥对象进行加锁，他们会阻塞，知道获取锁，或者在mtx_timedlock函数中发生超时。不同的是，函数mtx_trylock会进行锁检测，如果该锁已经被其他线程占用，那么它会立即返回thrd_busy
	
	函数mtx_unlock对互斥对象mtx进行解锁
	
	下面的示例代码片段演示了互斥对象的使用场景
	
		static int account_balance;
		static mtx_t account_lock;
		
		if(mtx_init(&account_lock,mtx_plain) == thrd_error){
			/**/
		}
	
		int Sub(int amount){
				if(mtx_lock(&account_lock) == thrd_error){
					return -1;
				}
				account_balance -= amount;
				if(mtx_unlock(&account_lock) == thrd_error){
					return -1;
				}
				return 0;
		}
		int Add(int amount){
			if(mtx_lock(&account_lock) == thrd_error){
				return -1;
			}
			account_balance += amount;
			if(mtx_unlock(&account_lock) == thrd_error){
				return -1;
			}
			return 0;
		}

3. 条件变量

	**int cnd_init(cnd_t \*cond);**

	**int cnd_wait(cnd_t \*cond,mtx_t \*mtx);**

	**int cnd_timedwait(cnd_t \*restrict cond,mtx_t \*restrict mtx,
						const struct timespec \*restrict ts);**

	**void cnd_destory(cnd_t \*cond);**

	**int cnd_broadcast(cnd_t \*cond);**

	**int cnd_signal(cnd_t \*cond);**

所有的条件变量必须经过cnd_init函数初始化后才能够使用。

函数cnd_wait会对mtx互斥对象进行解锁操作，然后阻塞，直到条件变量cond被cnd_signal或cnd_broadcast函数调用唤醒。当前线程变为非阻塞时，它将在返回之前锁定mtx互斥对象。

函数cnd_timedwait与函数cnd_wait类似，不同之处是，当前线程在ts时间点上还未能被唤醒时，它将返回thrd_timeout。函数cnd_wait和cnd_timewait在被调用之前，当前线程必须锁住mtx互斥对象。

函数cnd_broadcast用于唤醒那些当前已经阻塞在cond条件变量上的所有线程，函数cnd_signal则只能唤醒其中之一。

函数cnd_broadcast用于销毁条件变量。

4. 初始化

	**void call_once(once_flag \*flag,void (\*func)(void));**

	函数call_once通过使用flag来确保func在多线程环境只被调用一次

5. 特定于线程的存储

	创建一个key
	**int tss_create(tss_t \*key,tss_dtor_t dtor);**

	删除一个key
	**void tss_delete(tss_t key);**

	获取一个key
	**void \*tss_get(tss_t key);**

	设置一个key
	**int tss_set(tss_t key,void \*val);**

最后，除上面4个函数可以操作线程私有变量之外，还可以在声明定义线程私有变量时通过指定_Thread_local存储修饰符,像一般变量的方式访问线程私有变量。_Thread_local只能单独使用，或者跟static或extern一起使用。

### 建议117： 使用静态断言_Static_assert执行编译时检查（能够实现在编译的时候就进行检查提前发现错误）
### 建议118： 使用_Noreturn标识不返回值的函数

在C11标准中，引入了关键字_Noreturn来标识不返回值的函数。这就像内联函数一样，**它可以为编译器提供一种优化的标识，以保证编译器能够更好地优化程序的空间**，从而生成更快的可执行程序。使用示例如下面的代码所示：

		void noreturn ErrorHandler(char *val){}

# <center>第15章：保持良好的设计</center>

### 建议119： 避免错误地变量初始化

* 在变量使用之前都应该初始化
* 对局部变量进制使用extern关键字进行初始化
* 对数组，结构和联合的初始化列表应该显式描述，同时还应该遵循如下两条建议：
	* 对于数组，结构和联合的初始化列表应该使用大括号，并使用附加的大括号来指示嵌套的结构
	* 显示描述复杂数据类型的所有元素，避免忽略某个元素的初始化
* 枚举元素的初始化应该保持完整一致
	* 对于枚举元素的初始化，只有两种形式是安全的
		* 初始化所有的元素
		* 只初始化第一个元素
		
				{%highlight ruby%}
				int arr[3][2] = { {1,2}, {3,4}, {5,6} };
				enum DayfWeek{
					Sunday = 0;
					Monday = 1;
					Tuesday = 2;
					Wednesday = 3;
					Thursday = 4;
					Friday = 5;
					Saturday = 6;
				}	
				{%endhighlight%}
### 建议120： 谨慎使用内联函数（内联函数是以代码膨胀为代价的）
### 建议121： 避免在函数内定义占用内存很大的局部变量

	具体原因：如果函数内定义的局部变量使用内存过大，当函数出现多层嵌套调用的时候，就很有可能造成栈溢出从而引发系统故障。局部变量占用空间大小尽量控制在1KB

### 建议122： 谨慎设计函数参数的顺序和个数
### 建议123： 谨慎使用标准库函数

* C89（ANSI C）标准中定义了15个头文件

		assert.h
		ctype.h
		errno.h
		float.h
		limits.h
		locale.h
		math.h
		setjmp.h
		signal.h
		stdarg.h
		stddef.h
		stdio.h
		stdlib.h
		string.h
		time.h
* 1995年NA1批准了3个文件加入

		iso646.h
		wchar.h
		wctype.h
* C99增加了6个头文件
		complex.h
		fenv.h
		inttypes.h
		stdbool.h
		stdint.h
		tgmath.h
* C11标准中加了5个头文件
		stdalign.h
		stdatomic.h
		stdnoreturn.h
		threads.h
		uchar.h
**原则能用就不自己写！！！**

### 建议124： 避免不必要的函数调用
### 建议125： 谨慎程序中嵌入汇编代码（增加效率但是增加了开发难度降低了可移植性）



##关于sprintf()

{%highlight ruby%}

	在c语言中经常使用sprintf来进行数字到字符串的转化，注意

	char s[50];
	int x = 121;
	for(int i = 0;i<50;i++){
		s[i] = -1;
	}
	sprintf(s,"%d",x);//在sprintf之后s中的所有内容都会被改变

{%endhighlight%}

## 宏定义中的'\#\#'用法

	作用：
	将两个Token连接成一个Token

	示例：
		示例1：一个简单的示例
	
		#define LINK_MULTIPLE(a,b,c,d) a##_##b##_##c##_##d
		typedef struct _record_typeLINK_MULTIPLE(name,company,position,salary);
		// 这里这个语句将展开为：
		/ typedef struct _record_type name_company_position_salary;
		
		示例2：jos操作系统中的一个示例，加工传入的地址成一个新地址
		
		#define ENV_PASTE3(x, y, z) x ## y ## z
		
		#define ENV_CREATE(x, type)                                     \
        do {                                                            \
                extern uint8_t ENV_PASTE3(_binary_obj_, x, _start)[];   \
                env_create(ENV_PASTE3(_binary_obj_, x, _start),         \
                           type);                                       \
        } while (0)
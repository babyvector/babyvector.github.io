---
layout: post
title: 第三章笔记
categories: [C/C++]
tags: CBIR
---

## P113

如何理解复杂的引用变量的定义：

ia[2][3] = arr[0][0][0]

int (&row)[4] = ia[1]  //**把row绑定到ia的第二个4元素数组上**

//如何理解这样的定义的方法

在这个例子中，把row定义为一个含有4个整数的引用，然后将其绑定到ia的第二行中

同时我们还可以这样来理解：

int (&row)[4] = ia[1] = x[4] ==> &row = x ==> 所以row就是x的引用也就是一个含有4个元素的数组的引用。

## P114

{% highlight c++ %}
//在C++11中我们可以使用范围for语句来处理多维数组

size_t cnt = 0;
for(auto &row:ia)
	for(auto &col : row){
		col = cnt;
		++cnt;
}
//另外我们需要注意
size_t cnt = 0;
for(auto &row:ia)
	for(auto col : row){
		col = cnt;
		++cnt;
}
//这样写是正确的
size_t cnt = 0;
for(auto row:ia)
	for(auto col : row){
		col = cnt;
		++cnt;
}
//这样写是错误的。因为row不是引用类型，所以编译器初始化row时会自动将这些数组形式的元素
//（和其他类型的数组一样）转换为指向该数组内首元素的指针？？这样内层循环显然就是不合法的了。

{% endhighlight %}

## P115

指向多维数组的指针的定义以及解释

### 定义指向多维数组的指针时，千万不要忘了这个多维数组实际上是数组的数组
```
int ia[3][4];
int (*p)[4] = ia;
p = &ia[2];
```

如何分析p的相关策略：我们可以先由内层到外层一层一层的进行分析；先由括号内一层进行分析可得p是一个指针，这个指针指向的是一个维度为4的数组。**注意：不同于int *p[4] = x;**还有就是类似:

```
int *(&arry)[10] = ptrs;//
```

按照由内向外的顺序阅读上述语句，首先知道arry是一个引用，然后我们**由运算符的优先级顺序可知**我们应该观察右边，观察右边我们知道，arry引用的对象一个大小为10的数组，最后观察左边我们知道，数组的元素类型是指向int的指针。这样，arry就是一个含有10个int型指针的数组的引用。

## 116  typedef 和c++11中的using

using int_array = int[4];
typedef int int_array[4];

二者等价，不过使用using的时候表达式更为简单容易理解

## 129 赋值运算满足结合律

赋值运算满足右结合律，这一点与其他二元运算符不太一样

int ival ,jval;
ival = jval = 0;//正确二者都是被赋值为0

因为赋值运算返回的是其左侧的运算对象，而当两个变量类型不同的时候就不能这样做。

另外注意：**赋值运算的优先级较低**

但是：

string s1,s2;
s1 = s2 = "OK"//正确因为字面值“OK”被转化为了string类型

### 关于赋值运算符

```
while( (i = get_value()) != 42 ){;}
while( i = get_value() != 42 ){;}
//第二句是一个完全错误的语句，这种错误是由于优先级的大小不同而引起的。
```

## P131 ++ -- 自增与自减运算符的相关解释

1. 自增自减运算符不仅仅只是能将表达式书写的更加简单，而且是**因为有些迭代器不支持算术运算符，所以这个时候这能使用以上两个运算符**
2. 递增和递减运算符有两种形式：前置版本和后置版本。这两种运算符必须作用于左值运算对象。前置版本将对象本身作为左值返回，后置版本则将对象的原始值的副本作为右值返回。
3. 除非有必要否则不要使用递增递减的后置版本。（后置版本将原始值存储下来以便于返回这个未修改的内容。**存储下来如果不必要是一种浪费**）


## P133

*beg = toupper(*beg++);  //这样做是错误的，左右两侧的运算符都用到了beg

## P135

条件运算符的嵌套最好不要超过两至三层


---
layout: post
title: C++ Primer第6章
categories: [C/C++]
---

# 类的声明

类的定义中不能包含类自身

但是能够包含类的指针因为在类中加入类的时候类的定义仍然没有完毕，但是此时已经声明完毕。所以可以使用指针。

# 构造函数

1. 默认构造函数。当我们没有不定义构造函数的时候，编译器会自动帮我们生成一个默认构造函数在C++11中我们可以用class_name() = default;来生成默认构造函数
2. 构造函数初始值列表。
{%highlight ruby%}
Sales_data(const std::string &s):bookNo(s){}
Sales_data(const std::string &s,unsigned n,double p):bookNo(s),units_sold(n),revenue(p*n){}
{%endhighlight%}
# 拷贝函数

当我们

* 初始化变量
* 以值的方式传递（例如赋值）
* 以值的方式返回
时会执行拷贝操作

# 可变数据成员mutable a;

当我们希望一个数据a总是可变的时候，我们可以使用mutable来进行定义，定义之后即是我们的对象是const的对象数据a仍然可变。

# 类内数据成员的初始化

当我们想在定义一个对象之后就得到一个初始化对象，最好的初始化方法是使用**类内初始值**

# 友元

我们可以将
1. 非本类的普通非成员函数定义为友元
2. 将其他类定义为友元
3. 把其他类的成员函数定义为友元
注意：友元关系不存在传递性，也就是朋友的朋友并不是你的朋友

# 函数重载和友元(友元最重要的作用是限制或者增加访问权限)

类外函数通过在类内重新声明为友元就可以对函数进行重载，此时这个在类内被重载的函数能够访问类中的相关数据。

# 如果一个类是const类型的那么返回的*this也将是常量类型的

# 类的作用域问题

每个类都会定义自己的作用域。在类的作用域之外，普通的数据和函数成员只能由**对象，引用，或者指针使用成员的访问符来访问**，对于**类类型的成员只能使用作用域运算符访问**，跟在运算符之后的名字都必须是对应的类的成员。
一旦遇到类名，定义的剩余部分就是在类的作用域内了，剩余部分的包括参数列表和函数体。结果就是我们可以直接使用类的其他成员而无需再此授权了。


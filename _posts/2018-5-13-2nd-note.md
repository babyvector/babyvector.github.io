---
layout: post
title: 第二章笔记
---

## P30
1. C++的变量讲解C++中有两种基本的内置数据类型
	- 算术类型（integral type）
	- 空类型(void)
		
		其中算术类型包含了字符型、整数型、布尔值、和浮点数。空类型不对应具体值只是用于一些特殊的场合。C++标准中规定了尺寸的最小值，同时允许编译器赋予这些类型更大的尺寸。

	| 类型 | 含义 | 最小尺寸 |
	| :-: | :-: | :-: |
	|bool | 布尔类型	| 未定义|	
	|char | 字符	| 8位 |
	| wchar_t |	宽字符 |	16位 |
	| char16_t | Unicode字符	 | 16位 |
	|char32_t | Unicode字符	| 32位 |
	|short|短整型|16位|
	|int|整形	|16位
	|long|长整形|32位
	|long |long长整形|64位
	|float|单精度浮点型|6位有效数字
	|double|双精度浮点数|10位有效数字
	|long double	|拓展精度浮点数|10位有效数字

2. 大多数计算机以2的整数次幂个比特作为快来处理内存，**可寻址的最小内存块称为“字节(byte)”，存储的基本单元成为“字（word）”**一个字通常由几个字节组成
3. 与其他整形不同，字符型被分为三种：char,signed char 和unsigned char.特别需要注意的是：**类型char和类型signed char并不一样。**.尽管字符型有三种，但是字符的表现形式只有两种：带符号和无符号的。类型char实际上会表现为上述两种形式中的一种，具体是哪一种由**编译器决定**。
4. **类型选择的建议**
	- 当明确知晓数值不可能为负的时候，选用无符号数
	- （int型）整形的时候选用int，short太短，long又不够长，如果int太短使用longlong
	- *算术表达式中不能出现char和bool*因为不同机器上的char的规定不同，有的是有符号型有的是无符号型
	- （float型）浮点数使用double因为相比于float，double的处理速度并没有慢多少甚至更快
5.	char类型讲解，char中如果是有符号数那么其自身范围是：-127~127（理论上），-128~127（实际上）。而对于无符号类型的范围有0-255

## P32 类型转化

1.	类型转换要特别小心
	- 注意转换前后的精度损失等问题
2.	<p style="color:red">对于无符号数如果出现赋值超过自身最大值的处理方法</p>
	当我们赋给无符号类型一个超过它表示范围值的时候，结果是初始值对无符号类型表示数值总数取模后的余数。例如当我们将-1赋值给8比特大小的unsigned char 所得的结果是255
3. 避免无法预知和依赖编译器的行为。假定你设定int的字长为一个定值那么这个程序就是不可移植的因为他自身是依赖编译器的。
4. 要特别注意；不能给无符号数变量赋予负值这样会发生计算错误；但是我们很容易出现这种错误。
	
{% highlight c++ %}
unsigned int a;
int b;
unsigned int c;

c = a+b;
//这样计算的时候当a出现负值的时候一定会出现计算错误
//因为在计算的时候a与b都会被转化为
//无符号数参与运算

{% endhighlight %}

## P35计算机内部的整型数字存储方式

1. 原码：正数头一位为0，负数头一位为1
2. 反码：正数饭吗不变，负数反码取反
3. 补码：正数补码不变，负数的补码是负数反码加一
	
	注意：有符号的负数在运算前会被转化为负数的补码形式进行存储见下代码


{% highlight c++ %}
#include<iostream>

using namespace std;

int main(){

	unsigned u = 10, u2 = 42;
	cout << u2 - u << endl;		//32
	cout << u - u2 << endl;		//4294967264

	int i = 10, i2 = 42;
	cout << i2 - i << endl;		//32
	cout << i - i2 << endl;		//-32
	cout << i - u << endl;		//0	->假设当有符号整型为正数的时候   二进制第一位为0 
	cout << u - i << endl;		//0

	//addition
	int k = -10;
	unsigned uk = k;
	cout << uk << endl;		//2147483648

	cout << "end!" << endl;

	return 0;
}
{% endhighlight %}


## P35-36 字面值常量  转义序列

- 20 /*十进制*/
- 024 /*八进制*/
- 0x14 /*十六进制*/


两类字符程序员不能直接使用
- 不可打印字符例如退格等控制字符
- 在语言中具有特殊含义的字符（单引号，双引号，问号等）

## P44

::reused
reused 变量左边的域作用符为空。全局作用域本身就没有名字

## P48-P50

* 在指针中的含义是解引用。
* void*可以存放任意对象的地址，而且void*指针能够转化为任意类型的指针，但是用处并不多。

{% highlight c++ %}
//解释下列代码中为什么p合法而lp非法
	#include<iostream>
	
	using namespace std;
	
	int main(){
		int i = 42;
		void *p = &i;
		long *lp = &i;
		//int * 类型不能转化为long int*类型
		
		return 0;
	} 
{% endhighlight %}
	
## P51

* int *p;与int* p;二者的定义均是正确的但是第二个定义容易产生误导。
* 请讲述指针和引用的主要区别
	1. 两者之间的联系
	 	指针和引用都能提供对其他对象的间接访问
	2. 两者的差别
		两者在具体细节上有很大的差别；
		
		引用本身并不是一个对象，一旦定义了引用，就无法令其再绑定到另外的对象上 
		
		之后每次使用这个引用都是访问它最初绑定的对象
* <p style="color:red">指针和指针、指针和变量、变量和变量、变量和常量之间的类型转化</p>

{% highlight c++ %}
#include<iostream>
	
using namespace std;

int main(){

	//解释下列代码中有没有非法定义
	int i = 0;
	double *dp = &i;
	//取i的地址赋给dp 
	//改：地址不能够不声明的前提下进行类型转换 
	int *ip = i;
	//让ip指向0地址 
	//改：在涉及到地址的时候不能进行类型的转换（或者由于地址变量的大小与int类型的变量的大小不一致？） 
	int *p = &i;
	//取i的地址赋给p变量

	//都没有错误，都可以编译通过 
	//自己的判断完全错误

	//自己进行的实验
	double temp_test = i;
	i = temp_test;
	i = 2.9;

	return 0;
}
{% endhighlight %}



## P52-53

1. **引用本身不是一个对象，因此不能定义指向引用的指针。**
2. 如何对一个指针进行引用
```
int i = 42;
int *p;			//p是一个int型的指针
int *&r = p;	//r是一个对指针p的引用
//判定r是什么的判定方法  int *(&r) = p,因此可以断定r是一个引用是一个对指针的引用。
//要理解r的类型到底是什么，最简单的方法是从右向左阅读r的定义。离变量名最近的符号
//（此例中是&的符号&）对变量的类型有最直接的影响，因此r是一个引用。声明符的其余部分
//用以确定r引用的类型是什么。此例中的符号*说明r引用的是一个指针。最后声明的基本数据
//类型部分指出r引用的一个int指针。
note:
面对一条比较复杂的指针或者引用的声明语句时，从右向左阅读有助于弄清楚它的真正含义。
```

## P54-P55

1. 当以编译时初始化的方式定义一个const对象时
	const int buffsize = 512
编译器将在编译过程中把用到该变量的地方都替换成对应的值。也就是说，编译器会找到代码中所用到的buffsize的地方，然后用512替换。
2. 关于不同文件中共享一个const ...变量
3. 一般说的“对常量的引用”就是指“对const的引用”
4. **例外**允许常量绑定非常量,常量指针可以指向非常量

## P79 string部分

{% highlight c++ %}
string s = "value";
	int i = -100;
	//-> s.size()<i    一定是成立的因为size()函数返回一个无符号数
{% endhighlight %}



## P81 

{% highlight c++ %}
string + 部分
string s1 = "hello";
stirng s2 = "yourname";

string end = s1+", "+s2+'\n';

string支持这样做是因为标准库允许将字符字面值和字符串字面值转化为string对象。

//但是强调一点就是当我们把string对象和字符串字面值以及字符字面值混在一条语句中使用的时候，
//必须保证每个加法两侧的运算对象至少有一个是string。

e.g.
string s6 = s1+", "+"world"//正确
string s6 = "hello"+", "+s2//错误不能将字面值直接相加
{% endhighlight %}



